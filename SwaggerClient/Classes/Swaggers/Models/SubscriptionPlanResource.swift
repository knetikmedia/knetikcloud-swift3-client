//
// SubscriptionPlanResource.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation


open class SubscriptionPlanResource: JSONEncodable {
    public enum BillingCycleUnit: String { 
        case millisecond = "millisecond"
        case second = "second"
        case minute = "minute"
        case hour = "hour"
        case day = "day"
        case week = "week"
        case month = "month"
        case year = "year"
    }
    public enum FirstBillingCycleUnit: String { 
        case millisecond = "millisecond"
        case second = "second"
        case minute = "minute"
        case hour = "hour"
        case day = "day"
        case week = "week"
        case month = "month"
        case year = "year"
    }
    /** A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this subscription */
    public var additionalProperties: [String:Property]?
    /** The length of the billing cycle in number of billing cycle unit */
    public var billingCycleLength: Int32?
    /** The time period unit to apply to the length of billing cycles */
    public var billingCycleUnit: BillingCycleUnit?
    /** Whether this plan will be renewed on the consolidated billing cycle */
    public var consolidated: Bool?
    /** The ISO3 currency code to use for the fees */
    public var currencyCode: String?
    /** Used to schedule plan availability end date */
    public var endDate: Int64?
    /** Optional override for the length of the first billing cycle before the first recurring billing */
    public var firstBillingCycleLength: Int32?
    /** The time period unit to apply to the length of the first billing cycle. Required when first_billing_cycle_length is specified */
    public var firstBillingCycleUnit: FirstBillingCycleUnit?
    /** The number of late payment days before a subscription is canceled */
    public var gracePeriod: Int32?
    /** The id of the plan used to generate the SKUs */
    public var id: String?
    /** The fee charged when the subscription is purchased */
    public var initialFee: Double?
    /** The SKU to be used when purchasing the subscription through the cart */
    public var initialSku: String?
    /** The fee to add to the bill when an invoice has gone unpaid passed the grace period */
    public var latePaymentFee: Double?
    /** The SKU that will show on the invoice when the subscription is delinquent */
    public var latePaymentSku: String?
    /** Whether this plan is locked because it has been purchased by at least one user.  When locked, a number of properties can no longer be changed */
    public var locked: Bool?
    /** The number of charge attempts before the subscription becomes delinquent */
    public var maxBillAttempts: Int32?
    /** Maximum number of renewals. If a migration plan is provided, the subscription will automatically switch to it when this limit is reached */
    public var maxCycles: Int32?
    /** Automatically migrate to the specified plan when the subscription is first renewed */
    public var migrateToPlan: String?
    /** The minimum number of renewals to charge for */
    public var minCycles: Int32?
    /** The name of the plan used to generate the SKUs */
    public var name: String?
    /** Whether this plan is currently available */
    public var published: Bool?
    /** The fee to charge when a suspended subscription is to be re-activated */
    public var reactivationFee: Double?
    /** The SKU that will show on the invoice when the subscription is re-activated after a suspension */
    public var reactivationSku: String?
    /** The recurring fee to charge for each renewal */
    public var recurringFee: Double?
    /** The SKU that will show on the invoice when the subscription is activated */
    public var recurringSku: String?
    /** Used to schedule plan availability start date */
    public var startDate: Int64?

    public init() {}

    // MARK: JSONEncodable
    open func encodeToJSON() -> Any {
        var nillableDictionary = [String:Any?]()
        nillableDictionary["additional_properties"] = self.additionalProperties?.encodeToJSON()
        nillableDictionary["billing_cycle_length"] = self.billingCycleLength?.encodeToJSON()
        nillableDictionary["billing_cycle_unit"] = self.billingCycleUnit?.rawValue
        nillableDictionary["consolidated"] = self.consolidated
        nillableDictionary["currency_code"] = self.currencyCode
        nillableDictionary["end_date"] = self.endDate?.encodeToJSON()
        nillableDictionary["first_billing_cycle_length"] = self.firstBillingCycleLength?.encodeToJSON()
        nillableDictionary["first_billing_cycle_unit"] = self.firstBillingCycleUnit?.rawValue
        nillableDictionary["grace_period"] = self.gracePeriod?.encodeToJSON()
        nillableDictionary["id"] = self.id
        nillableDictionary["initial_fee"] = self.initialFee
        nillableDictionary["initial_sku"] = self.initialSku
        nillableDictionary["late_payment_fee"] = self.latePaymentFee
        nillableDictionary["late_payment_sku"] = self.latePaymentSku
        nillableDictionary["locked"] = self.locked
        nillableDictionary["max_bill_attempts"] = self.maxBillAttempts?.encodeToJSON()
        nillableDictionary["max_cycles"] = self.maxCycles?.encodeToJSON()
        nillableDictionary["migrate_to_plan"] = self.migrateToPlan
        nillableDictionary["min_cycles"] = self.minCycles?.encodeToJSON()
        nillableDictionary["name"] = self.name
        nillableDictionary["published"] = self.published
        nillableDictionary["reactivation_fee"] = self.reactivationFee
        nillableDictionary["reactivation_sku"] = self.reactivationSku
        nillableDictionary["recurring_fee"] = self.recurringFee
        nillableDictionary["recurring_sku"] = self.recurringSku
        nillableDictionary["start_date"] = self.startDate?.encodeToJSON()
        let dictionary: [String:Any] = APIHelper.rejectNil(nillableDictionary) ?? [:]
        return dictionary
    }
}

// Models.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for (key, value) in rawHeader {
            header[key as! String] = value as? String
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }

        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject where T.RawValue == U>(clazz: T, source: AnyObject) -> Decoded<T?> {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for AchievementDefinitionResource
        Decoders.addDecoder(clazz: AchievementDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AchievementDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? AchievementDefinitionResource() : instance as! AchievementDefinitionResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["hidden"] as AnyObject?) {
                
                case let .success(value): result.hidden = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["required_progress"] as AnyObject?) {
                
                case let .success(value): result.requiredProgress = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["rule_id"] as AnyObject?) {
                
                case let .success(value): result.ruleId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["trigger_event_name"] as AnyObject?) {
                
                case let .success(value): result.triggerEventName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "AchievementDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for ActionResource
        Decoders.addDecoder(clazz: ActionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActionResource() : instance as! ActionResource
                switch Decoders.decodeOptional(clazz: ActionResource.Category.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [ActionVariableResource].self, source: sourceDictionary["variables"] as AnyObject?) {
                
                case let .success(value): result.variables = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActionResource", actual: "\(source)"))
            }
        }
        // Decoder for ActionVariableResource
        Decoders.addDecoder(clazz: ActionVariableResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActionVariableResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActionVariableResource() : instance as! ActionVariableResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["optional"] as AnyObject?) {
                
                case let .success(value): result._optional = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActionVariableResource", actual: "\(source)"))
            }
        }
        // Decoder for ActivityEntitlementResource
        Decoders.addDecoder(clazz: ActivityEntitlementResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActivityEntitlementResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActivityEntitlementResource() : instance as! ActivityEntitlementResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["item_id"] as AnyObject?) {
                
                case let .success(value): result.itemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["price"] as AnyObject?) {
                
                case let .success(value): result.price = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActivityEntitlementResource", actual: "\(source)"))
            }
        }
        // Decoder for ActivityOccurrenceCreationFailure
        Decoders.addDecoder(clazz: ActivityOccurrenceCreationFailure.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActivityOccurrenceCreationFailure> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActivityOccurrenceCreationFailure() : instance as! ActivityOccurrenceCreationFailure
                switch Decoders.decodeOptional(clazz: [ActivityOccurrenceJoinResult].self, source: sourceDictionary["user_results"] as AnyObject?) {
                
                case let .success(value): result.userResults = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActivityOccurrenceCreationFailure", actual: "\(source)"))
            }
        }
        // Decoder for ActivityOccurrenceJoinResult
        Decoders.addDecoder(clazz: ActivityOccurrenceJoinResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActivityOccurrenceJoinResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActivityOccurrenceJoinResult() : instance as! ActivityOccurrenceJoinResult
                switch Decoders.decodeOptional(clazz: ActivityEntitlementResource.self, source: sourceDictionary["entitlement"] as AnyObject?) {
                
                case let .success(value): result.entitlement = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["error_code"] as AnyObject?) {
                
                case let .success(value): result.errorCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): result.message = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActivityOccurrenceJoinResult", actual: "\(source)"))
            }
        }
        // Decoder for ActivityOccurrenceResource
        Decoders.addDecoder(clazz: ActivityOccurrenceResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActivityOccurrenceResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActivityOccurrenceResource() : instance as! ActivityOccurrenceResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["activity_id"] as AnyObject?) {
                
                case let .success(value): result.activityId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["challenge_activity_id"] as AnyObject?) {
                
                case let .success(value): result.challengeActivityId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: ActivityEntitlementResource.self, source: sourceDictionary["entitlement"] as AnyObject?) {
                
                case let .success(value): result.entitlement = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["event_id"] as AnyObject?) {
                
                case let .success(value): result.eventId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: ActivityOccurrenceResource.RewardStatus.self, source: sourceDictionary["reward_status"] as AnyObject?) {
                
                case let .success(value): result.rewardStatus = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [SelectedSettingResource].self, source: sourceDictionary["settings"] as AnyObject?) {
                
                case let .success(value): result.settings = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["simulated"] as AnyObject?) {
                
                case let .success(value): result.simulated = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["start_date"] as AnyObject?) {
                
                case let .success(value): result.startDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: ActivityOccurrenceResource.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [ActivityUserResource].self, source: sourceDictionary["users"] as AnyObject?) {
                
                case let .success(value): result.users = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActivityOccurrenceResource", actual: "\(source)"))
            }
        }
        // Decoder for ActivityOccurrenceResults
        Decoders.addDecoder(clazz: ActivityOccurrenceResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActivityOccurrenceResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActivityOccurrenceResults() : instance as! ActivityOccurrenceResults
                switch Decoders.decodeOptional(clazz: [UserActivityResults].self, source: sourceDictionary["users"] as AnyObject?) {
                
                case let .success(value): result.users = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActivityOccurrenceResults", actual: "\(source)"))
            }
        }
        // Decoder for ActivityOccurrenceResultsResource
        Decoders.addDecoder(clazz: ActivityOccurrenceResultsResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActivityOccurrenceResultsResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActivityOccurrenceResultsResource() : instance as! ActivityOccurrenceResultsResource
                switch Decoders.decodeOptional(clazz: [UserActivityResultsResource].self, source: sourceDictionary["users"] as AnyObject?) {
                
                case let .success(value): result.users = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActivityOccurrenceResultsResource", actual: "\(source)"))
            }
        }
        // Decoder for ActivityResource
        Decoders.addDecoder(clazz: ActivityResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActivityResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActivityResource() : instance as! ActivityResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [ActivityEntitlementResource].self, source: sourceDictionary["entitlements"] as AnyObject?) {
                
                case let .success(value): result.entitlements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["launch"] as AnyObject?) {
                
                case let .success(value): result.launch = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: RewardSetResource.self, source: sourceDictionary["reward_set"] as AnyObject?) {
                
                case let .success(value): result.rewardSet = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [AvailableSettingResource].self, source: sourceDictionary["settings"] as AnyObject?) {
                
                case let .success(value): result.settings = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template_id"] as AnyObject?) {
                
                case let .success(value): result.templateId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActivityResource", actual: "\(source)"))
            }
        }
        // Decoder for ActivityUserResource
        Decoders.addDecoder(clazz: ActivityUserResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ActivityUserResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ActivityUserResource() : instance as! ActivityUserResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["host"] as AnyObject?) {
                
                case let .success(value): result.host = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["joined_date"] as AnyObject?) {
                
                case let .success(value): result.joinedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["left_date"] as AnyObject?) {
                
                case let .success(value): result.leftDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: MetricResource.self, source: sourceDictionary["metric"] as AnyObject?) {
                
                case let .success(value): result.metric = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: ActivityUserResource.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ActivityUserResource", actual: "\(source)"))
            }
        }
        // Decoder for AddressResource
        Decoders.addDecoder(clazz: AddressResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AddressResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? AddressResource() : instance as! AddressResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                
                case let .success(value): result.address1 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                
                case let .success(value): result.address2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?) {
                
                case let .success(value): result.city = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country_code"] as AnyObject?) {
                
                case let .success(value): result.countryCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postal_code"] as AnyObject?) {
                
                case let .success(value): result.postalCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state_code"] as AnyObject?) {
                
                case let .success(value): result.stateCode = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "AddressResource", actual: "\(source)"))
            }
        }
        // Decoder for AggregateCountResource
        Decoders.addDecoder(clazz: AggregateCountResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AggregateCountResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? AggregateCountResource() : instance as! AggregateCountResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["count"] as AnyObject?) {
                
                case let .success(value): result.count = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["date"] as AnyObject?) {
                
                case let .success(value): result.date = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "AggregateCountResource", actual: "\(source)"))
            }
        }
        // Decoder for AggregateInvoiceReportResource
        Decoders.addDecoder(clazz: AggregateInvoiceReportResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AggregateInvoiceReportResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? AggregateInvoiceReportResource() : instance as! AggregateInvoiceReportResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["count"] as AnyObject?) {
                
                case let .success(value): result.count = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["date"] as AnyObject?) {
                
                case let .success(value): result.date = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["revenue"] as AnyObject?) {
                
                case let .success(value): result.revenue = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["user_count"] as AnyObject?) {
                
                case let .success(value): result.userCount = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "AggregateInvoiceReportResource", actual: "\(source)"))
            }
        }
        // Decoder for AmazonS3Activity
        Decoders.addDecoder(clazz: AmazonS3Activity.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AmazonS3Activity> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? AmazonS3Activity() : instance as! AmazonS3Activity
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["action"] as AnyObject?) {
                
                case let .success(value): result.action = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cdn_url"] as AnyObject?) {
                
                case let .success(value): result.cdnUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["filename"] as AnyObject?) {
                
                case let .success(value): result.filename = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["object_key"] as AnyObject?) {
                
                case let .success(value): result.objectKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): result.url = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "AmazonS3Activity", actual: "\(source)"))
            }
        }
        // Decoder for AnswerResource
        Decoders.addDecoder(clazz: AnswerResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AnswerResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? AnswerResource() : instance as! AnswerResource
                switch Decoders.decodeOptional(clazz: Property.self, source: sourceDictionary["answer"] as AnyObject?) {
                
                case let .success(value): result.answer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["correct"] as AnyObject?) {
                
                case let .success(value): result.correct = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "AnswerResource", actual: "\(source)"))
            }
        }
        // Decoder for ApplyPaymentRequest
        Decoders.addDecoder(clazz: ApplyPaymentRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ApplyPaymentRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ApplyPaymentRequest() : instance as! ApplyPaymentRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["receipt"] as AnyObject?) {
                
                case let .success(value): result.receipt = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["transaction_id"] as AnyObject?) {
                
                case let .success(value): result.transactionId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ApplyPaymentRequest", actual: "\(source)"))
            }
        }
        // Decoder for ArticleResource
        Decoders.addDecoder(clazz: ArticleResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ArticleResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ArticleResource() : instance as! ArticleResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): result.active = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["body"] as AnyObject?) {
                
                case let .success(value): result.body = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: NestedCategory.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["title"] as AnyObject?) {
                
                case let .success(value): result.title = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ArticleResource", actual: "\(source)"))
            }
        }
        // Decoder for ArtistResource
        Decoders.addDecoder(clazz: ArtistResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ArtistResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ArtistResource() : instance as! ArtistResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["born"] as AnyObject?) {
                
                case let .success(value): result.born = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["contribution_count"] as AnyObject?) {
                
                case let .success(value): result.contributionCount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [ContributionResource].self, source: sourceDictionary["contributions"] as AnyObject?) {
                
                case let .success(value): result.contributions = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["died"] as AnyObject?) {
                
                case let .success(value): result.died = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["priority"] as AnyObject?) {
                
                case let .success(value): result.priority = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ArtistResource", actual: "\(source)"))
            }
        }
        // Decoder for AvailableSettingResource
        Decoders.addDecoder(clazz: AvailableSettingResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AvailableSettingResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? AvailableSettingResource() : instance as! AvailableSettingResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["advanced_option"] as AnyObject?) {
                
                case let .success(value): result.advancedOption = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["default_value"] as AnyObject?) {
                
                case let .success(value): result.defaultValue = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["key"] as AnyObject?) {
                
                case let .success(value): result.key = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [SettingOption].self, source: sourceDictionary["options"] as AnyObject?) {
                
                case let .success(value): result.options = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "AvailableSettingResource", actual: "\(source)"))
            }
        }
        // Decoder for BareActivityResource
        Decoders.addDecoder(clazz: BareActivityResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BareActivityResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BareActivityResource() : instance as! BareActivityResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["launch"] as AnyObject?) {
                
                case let .success(value): result.launch = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BareActivityResource", actual: "\(source)"))
            }
        }
        // Decoder for BareChallengeActivityResource
        Decoders.addDecoder(clazz: BareChallengeActivityResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BareChallengeActivityResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BareChallengeActivityResource() : instance as! BareChallengeActivityResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["activity_id"] as AnyObject?) {
                
                case let .success(value): result.activityId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["challenge_id"] as AnyObject?) {
                
                case let .success(value): result.challengeId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BareChallengeActivityResource", actual: "\(source)"))
            }
        }
        // Decoder for Batch
        Decoders.addDecoder(clazz: Batch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Batch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Batch() : instance as! Batch
                switch Decoders.decodeOptional(clazz: [BatchRequest].self, source: sourceDictionary["batch"] as AnyObject?) {
                
                case let .success(value): result.batch = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["timeout"] as AnyObject?) {
                
                case let .success(value): result.timeout = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Batch", actual: "\(source)"))
            }
        }
        // Decoder for BatchRequest
        Decoders.addDecoder(clazz: BatchRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BatchRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BatchRequest() : instance as! BatchRequest
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["body"] as AnyObject?) {
                
                case let .success(value): result.body = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["content_type"] as AnyObject?) {
                
                case let .success(value): result.contentType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["method"] as AnyObject?) {
                
                case let .success(value): result.method = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["timeout"] as AnyObject?) {
                
                case let .success(value): result.timeout = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?) {
                
                case let .success(value): result.token = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uri"] as AnyObject?) {
                
                case let .success(value): result.uri = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BatchRequest", actual: "\(source)"))
            }
        }
        // Decoder for BatchResult
        Decoders.addDecoder(clazz: BatchResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BatchResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BatchResult() : instance as! BatchResult
                switch Decoders.decodeOptional(clazz: [BatchReturn].self, source: sourceDictionary["batch_return"] as AnyObject?) {
                
                case let .success(value): result.batchReturn = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BatchResult", actual: "\(source)"))
            }
        }
        // Decoder for BatchReturn
        Decoders.addDecoder(clazz: BatchReturn.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BatchReturn> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BatchReturn() : instance as! BatchReturn
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["body"] as AnyObject?) {
                
                case let .success(value): result.body = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["code"] as AnyObject?) {
                
                case let .success(value): result.code = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["uri"] as AnyObject?) {
                
                case let .success(value): result.uri = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BatchReturn", actual: "\(source)"))
            }
        }
        // Decoder for Behavior
        Decoders.addDecoder(clazz: Behavior.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Behavior> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                // Check discriminator to support inheritance
                if let discriminator = sourceDictionary["type_hint"] as? String, instance == nil && discriminator != "Behavior"{
                    return Decoders.decode(clazz: Behavior.self, discriminator: discriminator, source: source)
                }
                let result = instance == nil ? Behavior() : instance as! Behavior
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Behavior", actual: "\(source)"))
            }
        }
        // Decoder for BehaviorDefinitionResource
        Decoders.addDecoder(clazz: BehaviorDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BehaviorDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BehaviorDefinitionResource() : instance as! BehaviorDefinitionResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Behavior].self, source: sourceDictionary["prerequisite_behaviors"] as AnyObject?) {
                
                case let .success(value): result.prerequisiteBehaviors = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PropertyFieldResource].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): result.properties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BehaviorDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for BillingReport
        Decoders.addDecoder(clazz: BillingReport.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BillingReport> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BillingReport() : instance as! BillingReport
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): result.created = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["last_known_failures"] as AnyObject?) {
                
                case let .success(value): result.lastKnownFailures = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:Int32].self, source: sourceDictionary["statistics"] as AnyObject?) {
                
                case let .success(value): result.statistics = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BillingReport", actual: "\(source)"))
            }
        }
        // Decoder for BooleanResource
        Decoders.addDecoder(clazz: BooleanResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BooleanResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BooleanResource() : instance as! BooleanResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BooleanResource", actual: "\(source)"))
            }
        }
        // Decoder for BreCategoryResource
        Decoders.addDecoder(clazz: BreCategoryResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BreCategoryResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BreCategoryResource() : instance as! BreCategoryResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BreCategoryResource", actual: "\(source)"))
            }
        }
        // Decoder for BreEvent
        Decoders.addDecoder(clazz: BreEvent.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BreEvent> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BreEvent() : instance as! BreEvent
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["event_name"] as AnyObject?) {
                
                case let .success(value): result.eventName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["params"] as AnyObject?) {
                
                case let .success(value): result.params = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BreEvent", actual: "\(source)"))
            }
        }
        // Decoder for BreEventLog
        Decoders.addDecoder(clazz: BreEventLog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BreEventLog> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BreEventLog() : instance as! BreEventLog
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer"] as AnyObject?) {
                
                case let .success(value): result.customer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["event_id"] as AnyObject?) {
                
                case let .success(value): result.eventId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["event_name"] as AnyObject?) {
                
                case let .success(value): result.eventName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["event_start_date"] as AnyObject?) {
                
                case let .success(value): result.eventStartDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["parameters"] as AnyObject?) {
                
                case let .success(value): result.parameters = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [BreRuleLog].self, source: sourceDictionary["rules"] as AnyObject?) {
                
                case let .success(value): result.rules = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BreEventLog", actual: "\(source)"))
            }
        }
        // Decoder for BreGlobalResource
        Decoders.addDecoder(clazz: BreGlobalResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BreGlobalResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BreGlobalResource() : instance as! BreGlobalResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["key"] as AnyObject?) {
                
                case let .success(value): result.key = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [BreGlobalScopeDefinition].self, source: sourceDictionary["scopes"] as AnyObject?) {
                
                case let .success(value): result.scopes = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["system_global"] as AnyObject?) {
                
                case let .success(value): result.systemGlobal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BreGlobalResource", actual: "\(source)"))
            }
        }
        // Decoder for BreGlobalScopeDefinition
        Decoders.addDecoder(clazz: BreGlobalScopeDefinition.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BreGlobalScopeDefinition> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BreGlobalScopeDefinition() : instance as! BreGlobalScopeDefinition
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BreGlobalScopeDefinition", actual: "\(source)"))
            }
        }
        // Decoder for BreRule
        Decoders.addDecoder(clazz: BreRule.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BreRule> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BreRule() : instance as! BreRule
                switch Decoders.decodeOptional(clazz: ActionResource.self, source: sourceDictionary["actions"] as AnyObject?) {
                
                case let .success(value): result.actions = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: PredicateOperation.self, source: sourceDictionary["condition"] as AnyObject?) {
                
                case let .success(value): result.condition = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["condition_text"] as AnyObject?) {
                
                case let .success(value): result.conditionText = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["enabled"] as AnyObject?) {
                
                case let .success(value): result.enabled = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["end_date"] as AnyObject?) {
                
                case let .success(value): result.endDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["event_name"] as AnyObject?) {
                
                case let .success(value): result.eventName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["start_date"] as AnyObject?) {
                
                case let .success(value): result.startDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["system_rule"] as AnyObject?) {
                
                case let .success(value): result.systemRule = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BreRule", actual: "\(source)"))
            }
        }
        // Decoder for BreRuleLog
        Decoders.addDecoder(clazz: BreRuleLog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BreRuleLog> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BreRuleLog() : instance as! BreRuleLog
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["ran"] as AnyObject?) {
                
                case let .success(value): result.ran = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["reason"] as AnyObject?) {
                
                case let .success(value): result.reason = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["rule_end_date"] as AnyObject?) {
                
                case let .success(value): result.ruleEndDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["rule_id"] as AnyObject?) {
                
                case let .success(value): result.ruleId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["rule_name"] as AnyObject?) {
                
                case let .success(value): result.ruleName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["rule_start_date"] as AnyObject?) {
                
                case let .success(value): result.ruleStartDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BreRuleLog", actual: "\(source)"))
            }
        }
        // Decoder for BreTriggerParameterDefinition
        Decoders.addDecoder(clazz: BreTriggerParameterDefinition.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BreTriggerParameterDefinition> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BreTriggerParameterDefinition() : instance as! BreTriggerParameterDefinition
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["optional"] as AnyObject?) {
                
                case let .success(value): result._optional = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BreTriggerParameterDefinition", actual: "\(source)"))
            }
        }
        // Decoder for BreTriggerResource
        Decoders.addDecoder(clazz: BreTriggerResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BreTriggerResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BreTriggerResource() : instance as! BreTriggerResource
                switch Decoders.decodeOptional(clazz: BreTriggerResource.Category.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["event_name"] as AnyObject?) {
                
                case let .success(value): result.eventName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [BreTriggerParameterDefinition].self, source: sourceDictionary["parameters"] as AnyObject?) {
                
                case let .success(value): result.parameters = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["system_trigger"] as AnyObject?) {
                
                case let .success(value): result.systemTrigger = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["trigger_description"] as AnyObject?) {
                
                case let .success(value): result.triggerDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["trigger_name"] as AnyObject?) {
                
                case let .success(value): result.triggerName = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BreTriggerResource", actual: "\(source)"))
            }
        }
        // Decoder for BroadcastableEvent
        Decoders.addDecoder(clazz: BroadcastableEvent.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BroadcastableEvent> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                // Check discriminator to support inheritance
                if let discriminator = sourceDictionary["type"] as? String, instance == nil && discriminator != "BroadcastableEvent"{
                    return Decoders.decode(clazz: BroadcastableEvent.self, discriminator: discriminator, source: source)
                }
                let result = instance == nil ? BroadcastableEvent() : instance as! BroadcastableEvent
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client"] as AnyObject?) {
                
                case let .success(value): result.client = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer"] as AnyObject?) {
                
                case let .success(value): result.customer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["do_not_broadcast"] as AnyObject?) {
                
                case let .success(value): result.doNotBroadcast = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["section"] as AnyObject?) {
                
                case let .success(value): result.section = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["source"] as AnyObject?) {
                
                case let .success(value): result.source = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["specifics"] as AnyObject?) {
                
                case let .success(value): result.specifics = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["synchronous"] as AnyObject?) {
                
                case let .success(value): result.synchronous = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                
                case let .success(value): result.timestamp = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BroadcastableEvent", actual: "\(source)"))
            }
        }
        // Decoder for BundledSku
        Decoders.addDecoder(clazz: BundledSku.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BundledSku> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BundledSku() : instance as! BundledSku
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["price_override"] as AnyObject?) {
                
                case let .success(value): result.priceOverride = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["quantity"] as AnyObject?) {
                
                case let .success(value): result.quantity = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BundledSku", actual: "\(source)"))
            }
        }
        // Decoder for CampaignResource
        Decoders.addDecoder(clazz: CampaignResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CampaignResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CampaignResource() : instance as! CampaignResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): result.active = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["leaderboard_strategy"] as AnyObject?) {
                
                case let .success(value): result.leaderboardStrategy = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["next_challenge"] as AnyObject?) {
                
                case let .success(value): result.nextChallenge = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["next_challenge_date"] as AnyObject?) {
                
                case let .success(value): result.nextChallengeDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: RewardSetResource.self, source: sourceDictionary["reward_set"] as AnyObject?) {
                
                case let .success(value): result.rewardSet = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CampaignResource.RewardStatus.self, source: sourceDictionary["reward_status"] as AnyObject?) {
                
                case let .success(value): result.rewardStatus = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CampaignResource", actual: "\(source)"))
            }
        }
        // Decoder for Cart
        Decoders.addDecoder(clazz: Cart.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Cart> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Cart() : instance as! Cart
                switch Decoders.decodeOptional(clazz: [CartShippingOption].self, source: sourceDictionary["available_shipping_options"] as AnyObject?) {
                
                case let .success(value): result.availableShippingOptions = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["country_tax"] as AnyObject?) {
                
                case let .success(value): result.countryTax = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [CouponDefinition].self, source: sourceDictionary["coupons"] as AnyObject?) {
                
                case let .success(value): result.coupons = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): result.created = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["discount_total"] as AnyObject?) {
                
                case let .success(value): result.discountTotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["error_code"] as AnyObject?) {
                
                case let .success(value): result.errorCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["error_message"] as AnyObject?) {
                
                case let .success(value): result.errorMessage = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["grand_total"] as AnyObject?) {
                
                case let .success(value): result.grandTotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [CartLineItem].self, source: sourceDictionary["items"] as AnyObject?) {
                
                case let .success(value): result.items = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["owner"] as AnyObject?) {
                
                case let .success(value): result.owner = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [CartShippingOption].self, source: sourceDictionary["selected_shipping_options"] as AnyObject?) {
                
                case let .success(value): result.selectedShippingOptions = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["shippable"] as AnyObject?) {
                
                case let .success(value): result.shippable = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CartShippingAddressRequest.self, source: sourceDictionary["shipping_address"] as AnyObject?) {
                
                case let .success(value): result.shippingAddress = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["shipping_cost"] as AnyObject?) {
                
                case let .success(value): result.shippingCost = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["state_tax"] as AnyObject?) {
                
                case let .success(value): result.stateTax = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Cart.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["subtotal"] as AnyObject?) {
                
                case let .success(value): result.subtotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated"] as AnyObject?) {
                
                case let .success(value): result.updated = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Cart", actual: "\(source)"))
            }
        }
        // Decoder for CartItemRequest
        Decoders.addDecoder(clazz: CartItemRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CartItemRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CartItemRequest() : instance as! CartItemRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["affiliate_key"] as AnyObject?) {
                
                case let .success(value): result.affiliateKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["catalog_sku"] as AnyObject?) {
                
                case let .success(value): result.catalogSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["price_override"] as AnyObject?) {
                
                case let .success(value): result.priceOverride = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["quantity"] as AnyObject?) {
                
                case let .success(value): result.quantity = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CartItemRequest", actual: "\(source)"))
            }
        }
        // Decoder for CartLineItem
        Decoders.addDecoder(clazz: CartLineItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CartLineItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CartLineItem() : instance as! CartLineItem
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Discount.self, source: sourceDictionary["discount"] as AnyObject?) {
                
                case let .success(value): result.discount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["line_total"] as AnyObject?) {
                
                case let .success(value): result.lineTotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["original_line_total"] as AnyObject?) {
                
                case let .success(value): result.originalLineTotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["original_unit_price"] as AnyObject?) {
                
                case let .success(value): result.originalUnitPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["qty"] as AnyObject?) {
                
                case let .success(value): result.qty = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sale_name"] as AnyObject?) {
                
                case let .success(value): result.saleName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku_description"] as AnyObject?) {
                
                case let .success(value): result.skuDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["store_item_id"] as AnyObject?) {
                
                case let .success(value): result.storeItemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["thumb_url"] as AnyObject?) {
                
                case let .success(value): result.thumbUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["unit_price"] as AnyObject?) {
                
                case let .success(value): result.unitPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vendor_id"] as AnyObject?) {
                
                case let .success(value): result.vendorId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vendor_name"] as AnyObject?) {
                
                case let .success(value): result.vendorName = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CartLineItem", actual: "\(source)"))
            }
        }
        // Decoder for CartShippableResponse
        Decoders.addDecoder(clazz: CartShippableResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CartShippableResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CartShippableResponse() : instance as! CartShippableResponse
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["cart_id"] as AnyObject?) {
                
                case let .success(value): result.cartId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["shippable"] as AnyObject?) {
                
                case let .success(value): result.shippable = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CartShippableResponse", actual: "\(source)"))
            }
        }
        // Decoder for CartShippingAddressRequest
        Decoders.addDecoder(clazz: CartShippingAddressRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CartShippingAddressRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CartShippingAddressRequest() : instance as! CartShippingAddressRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?) {
                
                case let .success(value): result.city = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country_code_iso3"] as AnyObject?) {
                
                case let .success(value): result.countryCodeIso3 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): result.email = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["first_name"] as AnyObject?) {
                
                case let .success(value): result.firstName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_name"] as AnyObject?) {
                
                case let .success(value): result.lastName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name_prefix"] as AnyObject?) {
                
                case let .success(value): result.namePrefix = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["order_notes"] as AnyObject?) {
                
                case let .success(value): result.orderNotes = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone_number"] as AnyObject?) {
                
                case let .success(value): result.phoneNumber = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postal_state_code"] as AnyObject?) {
                
                case let .success(value): result.postalStateCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shipping_address_line1"] as AnyObject?) {
                
                case let .success(value): result.shippingAddressLine1 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shipping_address_line2"] as AnyObject?) {
                
                case let .success(value): result.shippingAddressLine2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["zip"] as AnyObject?) {
                
                case let .success(value): result.zip = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CartShippingAddressRequest", actual: "\(source)"))
            }
        }
        // Decoder for CartShippingOption
        Decoders.addDecoder(clazz: CartShippingOption.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CartShippingOption> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CartShippingOption() : instance as! CartShippingOption
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["original_price"] as AnyObject?) {
                
                case let .success(value): result.originalPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["price"] as AnyObject?) {
                
                case let .success(value): result.price = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["shipping_item_id"] as AnyObject?) {
                
                case let .success(value): result.shippingItemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["taxable"] as AnyObject?) {
                
                case let .success(value): result.taxable = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vendor_id"] as AnyObject?) {
                
                case let .success(value): result.vendorId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vendor_name"] as AnyObject?) {
                
                case let .success(value): result.vendorName = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CartShippingOption", actual: "\(source)"))
            }
        }
        // Decoder for CartSummary
        Decoders.addDecoder(clazz: CartSummary.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CartSummary> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CartSummary() : instance as! CartSummary
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["grand_total"] as AnyObject?) {
                
                case let .success(value): result.grandTotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["items_in_cart"] as AnyObject?) {
                
                case let .success(value): result.itemsInCart = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CartSummary.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["subtotal"] as AnyObject?) {
                
                case let .success(value): result.subtotal = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CartSummary", actual: "\(source)"))
            }
        }
        // Decoder for CatalogSale
        Decoders.addDecoder(clazz: CatalogSale.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CatalogSale> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CatalogSale() : instance as! CatalogSale
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CatalogSale.DiscountType.self, source: sourceDictionary["discount_type"] as AnyObject?) {
                
                case let .success(value): result.discountType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["discount_value"] as AnyObject?) {
                
                case let .success(value): result.discountValue = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["item"] as AnyObject?) {
                
                case let .success(value): result.item = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["sale_end_date"] as AnyObject?) {
                
                case let .success(value): result.saleEndDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["sale_start_date"] as AnyObject?) {
                
                case let .success(value): result.saleStartDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["tag"] as AnyObject?) {
                
                case let .success(value): result.tag = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vendor"] as AnyObject?) {
                
                case let .success(value): result.vendor = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CatalogSale", actual: "\(source)"))
            }
        }
        // Decoder for CategoryResource
        Decoders.addDecoder(clazz: CategoryResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CategoryResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CategoryResource() : instance as! CategoryResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): result.active = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CategoryResource", actual: "\(source)"))
            }
        }
        // Decoder for ChallengeActivityResource
        Decoders.addDecoder(clazz: ChallengeActivityResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChallengeActivityResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ChallengeActivityResource() : instance as! ChallengeActivityResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["activity_id"] as AnyObject?) {
                
                case let .success(value): result.activityId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["challenge_id"] as AnyObject?) {
                
                case let .success(value): result.challengeId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: ActivityEntitlementResource.self, source: sourceDictionary["entitlement"] as AnyObject?) {
                
                case let .success(value): result.entitlement = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: RewardSetResource.self, source: sourceDictionary["reward_set"] as AnyObject?) {
                
                case let .success(value): result.rewardSet = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [SelectedSettingResource].self, source: sourceDictionary["settings"] as AnyObject?) {
                
                case let .success(value): result.settings = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ChallengeActivityResource", actual: "\(source)"))
            }
        }
        // Decoder for ChallengeEventParticipantResource
        Decoders.addDecoder(clazz: ChallengeEventParticipantResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChallengeEventParticipantResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ChallengeEventParticipantResource() : instance as! ChallengeEventParticipantResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): result.email = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullname"] as AnyObject?) {
                
                case let .success(value): result.fullname = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["score"] as AnyObject?) {
                
                case let .success(value): result.score = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ChallengeEventParticipantResource", actual: "\(source)"))
            }
        }
        // Decoder for ChallengeEventResource
        Decoders.addDecoder(clazz: ChallengeEventResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChallengeEventResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ChallengeEventResource() : instance as! ChallengeEventResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["challenge_id"] as AnyObject?) {
                
                case let .success(value): result.challengeId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["end_date"] as AnyObject?) {
                
                case let .success(value): result.endDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: ChallengeEventResource.RewardStatus.self, source: sourceDictionary["reward_status"] as AnyObject?) {
                
                case let .success(value): result.rewardStatus = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["start_date"] as AnyObject?) {
                
                case let .success(value): result.startDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ChallengeEventResource", actual: "\(source)"))
            }
        }
        // Decoder for ChallengeResource
        Decoders.addDecoder(clazz: ChallengeResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ChallengeResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ChallengeResource() : instance as! ChallengeResource
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["activities"] as AnyObject?) {
                
                case let .success(value): result.activities = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["campaign_id"] as AnyObject?) {
                
                case let .success(value): result.campaignId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["copy_of"] as AnyObject?) {
                
                case let .success(value): result.copyOf = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["end_date"] as AnyObject?) {
                
                case let .success(value): result.endDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["leaderboard_strategy"] as AnyObject?) {
                
                case let .success(value): result.leaderboardStrategy = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["next_event_date"] as AnyObject?) {
                
                case let .success(value): result.nextEventDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["reward_lag_minutes"] as AnyObject?) {
                
                case let .success(value): result.rewardLagMinutes = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: RewardSetResource.self, source: sourceDictionary["reward_set"] as AnyObject?) {
                
                case let .success(value): result.rewardSet = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Schedule.self, source: sourceDictionary["schedule"] as AnyObject?) {
                
                case let .success(value): result.schedule = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["start_date"] as AnyObject?) {
                
                case let .success(value): result.startDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ChallengeResource", actual: "\(source)"))
            }
        }
        // Decoder for ClientResource
        Decoders.addDecoder(clazz: ClientResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ClientResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ClientResource() : instance as! ClientResource
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["access_token_validity_seconds"] as AnyObject?) {
                
                case let .success(value): result.accessTokenValiditySeconds = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client_key"] as AnyObject?) {
                
                case let .success(value): result.clientKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["grant_types"] as AnyObject?) {
                
                case let .success(value): result.grantTypes = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["is_public"] as AnyObject?) {
                
                case let .success(value): result.isPublic = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["locked"] as AnyObject?) {
                
                case let .success(value): result.locked = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["redirect_uris"] as AnyObject?) {
                
                case let .success(value): result.redirectUris = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["refresh_token_validity_seconds"] as AnyObject?) {
                
                case let .success(value): result.refreshTokenValiditySeconds = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secret"] as AnyObject?) {
                
                case let .success(value): result.secret = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ClientResource", actual: "\(source)"))
            }
        }
        // Decoder for CollectionCountry
        Decoders.addDecoder(clazz: CollectionCountry.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CollectionCountry> in
            if let source = source as? Any {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias CollectionCountry", actual: "\(source)"))
            }
        }
        // Decoder for Collectionstring
        Decoders.addDecoder(clazz: Collectionstring.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Collectionstring> in
            if let source = source as? Any {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias Collectionstring", actual: "\(source)"))
            }
        }
        // Decoder for CommentResource
        Decoders.addDecoder(clazz: CommentResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CommentResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CommentResource() : instance as! CommentResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context"] as AnyObject?) {
                
                case let .success(value): result.context = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["context_id"] as AnyObject?) {
                
                case let .success(value): result.contextId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["summary"] as AnyObject?) {
                
                case let .success(value): result.summary = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CommentResource", actual: "\(source)"))
            }
        }
        // Decoder for CommentSearch
        Decoders.addDecoder(clazz: CommentSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CommentSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CommentSearch() : instance as! CommentSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context"] as AnyObject?) {
                
                case let .success(value): result.context = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["context_id"] as AnyObject?) {
                
                case let .success(value): result.contextId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["owner_id"] as AnyObject?) {
                
                case let .success(value): result.ownerId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["owner_username"] as AnyObject?) {
                
                case let .success(value): result.ownerUsername = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CommentSearch", actual: "\(source)"))
            }
        }
        // Decoder for Config
        Decoders.addDecoder(clazz: Config.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Config> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Config() : instance as! Config
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["public_read"] as AnyObject?) {
                
                case let .success(value): result.publicRead = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Config", actual: "\(source)"))
            }
        }
        // Decoder for ConfigLookupResource
        Decoders.addDecoder(clazz: ConfigLookupResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConfigLookupResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ConfigLookupResource() : instance as! ConfigLookupResource
                switch Decoders.decodeOptional(clazz: ExpressionResource.self, source: sourceDictionary["lookup_key"] as AnyObject?) {
                
                case let .success(value): result.lookupKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value_type"] as AnyObject?) {
                
                case let .success(value): result.valueType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ConfigLookupResource", actual: "\(source)"))
            }
        }
        // Decoder for ConstantResource
        Decoders.addDecoder(clazz: ConstantResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ConstantResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ConstantResource() : instance as! ConstantResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value_type"] as AnyObject?) {
                
                case let .success(value): result.valueType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ConstantResource", actual: "\(source)"))
            }
        }
        // Decoder for ContributionResource
        Decoders.addDecoder(clazz: ContributionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ContributionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ContributionResource() : instance as! ContributionResource
                switch Decoders.decodeOptional(clazz: SimpleReferenceResourcelong.self, source: sourceDictionary["artist"] as AnyObject?) {
                
                case let .success(value): result.artist = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleReferenceResourcelong.self, source: sourceDictionary["media"] as AnyObject?) {
                
                case let .success(value): result.media = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["role"] as AnyObject?) {
                
                case let .success(value): result.role = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ContributionResource", actual: "\(source)"))
            }
        }
        // Decoder for Country
        Decoders.addDecoder(clazz: Country.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Country> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Country() : instance as! Country
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["iso2"] as AnyObject?) {
                
                case let .success(value): result.iso2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["iso3"] as AnyObject?) {
                
                case let .success(value): result.iso3 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Country", actual: "\(source)"))
            }
        }
        // Decoder for CountryResource
        Decoders.addDecoder(clazz: CountryResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CountryResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CountryResource() : instance as! CountryResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["iso2"] as AnyObject?) {
                
                case let .success(value): result.iso2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["iso3"] as AnyObject?) {
                
                case let .success(value): result.iso3 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CountryResource", actual: "\(source)"))
            }
        }
        // Decoder for CountryTaxResource
        Decoders.addDecoder(clazz: CountryTaxResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CountryTaxResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CountryTaxResource() : instance as! CountryTaxResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country_iso3"] as AnyObject?) {
                
                case let .success(value): result.countryIso3 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["rate"] as AnyObject?) {
                
                case let .success(value): result.rate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["tax_shipping"] as AnyObject?) {
                
                case let .success(value): result.taxShipping = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CountryTaxResource", actual: "\(source)"))
            }
        }
        // Decoder for CouponDefinition
        Decoders.addDecoder(clazz: CouponDefinition.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CouponDefinition> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CouponDefinition() : instance as! CouponDefinition
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                
                case let .success(value): result.code = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CouponDefinition.DiscountType.self, source: sourceDictionary["discount_type"] as AnyObject?) {
                
                case let .success(value): result.discountType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["exclusive"] as AnyObject?) {
                
                case let .success(value): result.exclusive = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["max_discount"] as AnyObject?) {
                
                case let .success(value): result.maxDiscount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_quantity"] as AnyObject?) {
                
                case let .success(value): result.maxQuantity = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["min_cart_total"] as AnyObject?) {
                
                case let .success(value): result.minCartTotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["self_exclusive"] as AnyObject?) {
                
                case let .success(value): result.selfExclusive = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["target_item_id"] as AnyObject?) {
                
                case let .success(value): result.targetItemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CouponDefinition.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["valid_for_tags"] as AnyObject?) {
                
                case let .success(value): result.validForTags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vendor_id"] as AnyObject?) {
                
                case let .success(value): result.vendorId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CouponDefinition", actual: "\(source)"))
            }
        }
        // Decoder for CreateBillingAgreementRequest
        Decoders.addDecoder(clazz: CreateBillingAgreementRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CreateBillingAgreementRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CreateBillingAgreementRequest() : instance as! CreateBillingAgreementRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cancel_url"] as AnyObject?) {
                
                case let .success(value): result.cancelUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["return_url"] as AnyObject?) {
                
                case let .success(value): result.returnUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CreateBillingAgreementRequest", actual: "\(source)"))
            }
        }
        // Decoder for CreatePayPalPaymentRequest
        Decoders.addDecoder(clazz: CreatePayPalPaymentRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CreatePayPalPaymentRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CreatePayPalPaymentRequest() : instance as! CreatePayPalPaymentRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cancel_url"] as AnyObject?) {
                
                case let .success(value): result.cancelUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["return_url"] as AnyObject?) {
                
                case let .success(value): result.returnUrl = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CreatePayPalPaymentRequest", actual: "\(source)"))
            }
        }
        // Decoder for CurrencyResource
        Decoders.addDecoder(clazz: CurrencyResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CurrencyResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CurrencyResource() : instance as! CurrencyResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): result.active = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                
                case let .success(value): result.code = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["factor"] as AnyObject?) {
                
                case let .success(value): result.factor = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["icon"] as AnyObject?) {
                
                case let .success(value): result.icon = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CurrencyResource.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CurrencyResource", actual: "\(source)"))
            }
        }
        // Decoder for CustomerConfig
        Decoders.addDecoder(clazz: CustomerConfig.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CustomerConfig> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CustomerConfig() : instance as! CustomerConfig
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["aliases"] as AnyObject?) {
                
                case let .success(value): result.aliases = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: DatabaseConfig.self, source: sourceDictionary["database"] as AnyObject?) {
                
                case let .success(value): result.database = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: IOConfig.self, source: sourceDictionary["io"] as AnyObject?) {
                
                case let .success(value): result.io = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: S3Config.self, source: sourceDictionary["s3_config"] as AnyObject?) {
                
                case let .success(value): result.s3Config = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CustomerConfig", actual: "\(source)"))
            }
        }
        // Decoder for DatabaseConfig
        Decoders.addDecoder(clazz: DatabaseConfig.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DatabaseConfig> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DatabaseConfig() : instance as! DatabaseConfig
                switch Decoders.decodeOptional(clazz: MongoDatabaseConfig.self, source: sourceDictionary["mongo"] as AnyObject?) {
                
                case let .success(value): result.mongo = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SqlDatabaseConfig.self, source: sourceDictionary["sql"] as AnyObject?) {
                
                case let .success(value): result.sql = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DatabaseConfig", actual: "\(source)"))
            }
        }
        // Decoder for DateOperationResource
        Decoders.addDecoder(clazz: DateOperationResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DateOperationResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DateOperationResource() : instance as! DateOperationResource
                switch Decoders.decodeOptional(clazz: [ExpressionResource].self, source: sourceDictionary["args"] as AnyObject?) {
                
                case let .success(value): result.args = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["op"] as AnyObject?) {
                
                case let .success(value): result.op = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DateOperationResource", actual: "\(source)"))
            }
        }
        // Decoder for DeltaResource
        Decoders.addDecoder(clazz: DeltaResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DeltaResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DeltaResource() : instance as! DeltaResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["category_id"] as AnyObject?) {
                
                case let .success(value): result.categoryId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["media_type"] as AnyObject?) {
                
                case let .success(value): result.mediaType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["question_id"] as AnyObject?) {
                
                case let .success(value): result.questionId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: DeltaResource.State.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): result.state = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DeltaResource", actual: "\(source)"))
            }
        }
        // Decoder for DeviceResource
        Decoders.addDecoder(clazz: DeviceResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DeviceResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DeviceResource() : instance as! DeviceResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["authorization"] as AnyObject?) {
                
                case let .success(value): result.authorization = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: DeviceResource.Condition.self, source: sourceDictionary["condition"] as AnyObject?) {
                
                case let .success(value): result.condition = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["data"] as AnyObject?) {
                
                case let .success(value): result.data = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["device_type"] as AnyObject?) {
                
                case let .success(value): result.deviceType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                
                case let .success(value): result.location = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mac_address"] as AnyObject?) {
                
                case let .success(value): result.macAddress = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["make"] as AnyObject?) {
                
                case let .success(value): result.make = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["model"] as AnyObject?) {
                
                case let .success(value): result.model = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["os"] as AnyObject?) {
                
                case let .success(value): result.os = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["serial"] as AnyObject?) {
                
                case let .success(value): result.serial = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: DeviceResource.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [SimpleUserResource].self, source: sourceDictionary["users"] as AnyObject?) {
                
                case let .success(value): result.users = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DeviceResource", actual: "\(source)"))
            }
        }
        // Decoder for Discount
        Decoders.addDecoder(clazz: Discount.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Discount> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Discount() : instance as! Discount
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Discount", actual: "\(source)"))
            }
        }
        // Decoder for DispositionCount
        Decoders.addDecoder(clazz: DispositionCount.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DispositionCount> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DispositionCount() : instance as! DispositionCount
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["count"] as AnyObject?) {
                
                case let .success(value): result.count = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DispositionCount", actual: "\(source)"))
            }
        }
        // Decoder for DispositionResource
        Decoders.addDecoder(clazz: DispositionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DispositionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DispositionResource() : instance as! DispositionResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context"] as AnyObject?) {
                
                case let .success(value): result.context = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context_id"] as AnyObject?) {
                
                case let .success(value): result.contextId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DispositionResource", actual: "\(source)"))
            }
        }
        // Decoder for DoubleOperationResource
        Decoders.addDecoder(clazz: DoubleOperationResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DoubleOperationResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DoubleOperationResource() : instance as! DoubleOperationResource
                switch Decoders.decodeOptional(clazz: [ExpressionResource].self, source: sourceDictionary["args"] as AnyObject?) {
                
                case let .success(value): result.args = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["op"] as AnyObject?) {
                
                case let .success(value): result.op = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DoubleOperationResource", actual: "\(source)"))
            }
        }
        // Decoder for EntitlementGrantRequest
        Decoders.addDecoder(clazz: EntitlementGrantRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EntitlementGrantRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? EntitlementGrantRequest() : instance as! EntitlementGrantRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["entitlement_id"] as AnyObject?) {
                
                case let .success(value): result.entitlementId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "EntitlementGrantRequest", actual: "\(source)"))
            }
        }
        // Decoder for ErrorResource
        Decoders.addDecoder(clazz: ErrorResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ErrorResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ErrorResource() : instance as! ErrorResource
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["details"] as AnyObject?) {
                
                case let .success(value): result.details = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["field"] as AnyObject?) {
                
                case let .success(value): result.field = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): result.message = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ErrorResource", actual: "\(source)"))
            }
        }
        // Decoder for EventContextResource
        Decoders.addDecoder(clazz: EventContextResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EventContextResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? EventContextResource() : instance as! EventContextResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["event_name"] as AnyObject?) {
                
                case let .success(value): result.eventName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:ExpressionResource].self, source: sourceDictionary["parameters"] as AnyObject?) {
                
                case let .success(value): result.parameters = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "EventContextResource", actual: "\(source)"))
            }
        }
        // Decoder for ExpressionResource
        Decoders.addDecoder(clazz: ExpressionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ExpressionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                // Check discriminator to support inheritance
                if let discriminator = sourceDictionary["type"] as? String, instance == nil && discriminator != "ExpressionResource"{
                    return Decoders.decode(clazz: ExpressionResource.self, discriminator: discriminator, source: source)
                }
                let result = instance == nil ? ExpressionResource() : instance as! ExpressionResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ExpressionResource", actual: "\(source)"))
            }
        }
        // Decoder for Expressionobject
        Decoders.addDecoder(clazz: Expressionobject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Expressionobject> in
            if let source = source as? Any {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias Expressionobject", actual: "\(source)"))
            }
        }
        // Decoder for FacebookToken
        Decoders.addDecoder(clazz: FacebookToken.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FacebookToken> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FacebookToken() : instance as! FacebookToken
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["access_token"] as AnyObject?) {
                
                case let .success(value): result.accessToken = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FacebookToken", actual: "\(source)"))
            }
        }
        // Decoder for FattMerchantPaymentMethod
        Decoders.addDecoder(clazz: FattMerchantPaymentMethod.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FattMerchantPaymentMethod> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FattMerchantPaymentMethod() : instance as! FattMerchantPaymentMethod
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                
                case let .success(value): result.address1 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                
                case let .success(value): result.address2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address_city"] as AnyObject?) {
                
                case let .success(value): result.addressCity = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address_country"] as AnyObject?) {
                
                case let .success(value): result.addressCountry = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address_state"] as AnyObject?) {
                
                case let .success(value): result.addressState = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address_zip"] as AnyObject?) {
                
                case let .success(value): result.addressZip = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["card_last_four"] as AnyObject?) {
                
                case let .success(value): result.cardLastFour = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["created_at"] as AnyObject?) {
                
                case let .success(value): result.createdAt = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer_id"] as AnyObject?) {
                
                case let .success(value): result.customerId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["deleted_at"] as AnyObject?) {
                
                case let .success(value): result.deletedAt = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["nickname"] as AnyObject?) {
                
                case let .success(value): result.nickname = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["updated_at"] as AnyObject?) {
                
                case let .success(value): result.updatedAt = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FattMerchantPaymentMethod", actual: "\(source)"))
            }
        }
        // Decoder for FattMerchantPaymentMethodRequest
        Decoders.addDecoder(clazz: FattMerchantPaymentMethodRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FattMerchantPaymentMethodRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FattMerchantPaymentMethodRequest() : instance as! FattMerchantPaymentMethodRequest
                switch Decoders.decodeOptional(clazz: FattMerchantPaymentMethod.self, source: sourceDictionary["method"] as AnyObject?) {
                
                case let .success(value): result.method = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FattMerchantPaymentMethodRequest", actual: "\(source)"))
            }
        }
        // Decoder for FinalizeBillingAgreementRequest
        Decoders.addDecoder(clazz: FinalizeBillingAgreementRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FinalizeBillingAgreementRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FinalizeBillingAgreementRequest() : instance as! FinalizeBillingAgreementRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["new_default"] as AnyObject?) {
                
                case let .success(value): result.newDefault = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["payer_id"] as AnyObject?) {
                
                case let .success(value): result.payerId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?) {
                
                case let .success(value): result.token = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FinalizeBillingAgreementRequest", actual: "\(source)"))
            }
        }
        // Decoder for FinalizePayPalPaymentRequest
        Decoders.addDecoder(clazz: FinalizePayPalPaymentRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FinalizePayPalPaymentRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FinalizePayPalPaymentRequest() : instance as! FinalizePayPalPaymentRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["payer_id"] as AnyObject?) {
                
                case let .success(value): result.payerId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?) {
                
                case let .success(value): result.token = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FinalizePayPalPaymentRequest", actual: "\(source)"))
            }
        }
        // Decoder for FlagReportResource
        Decoders.addDecoder(clazz: FlagReportResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FlagReportResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FlagReportResource() : instance as! FlagReportResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context"] as AnyObject?) {
                
                case let .success(value): result.context = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context_id"] as AnyObject?) {
                
                case let .success(value): result.contextId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["reason"] as AnyObject?) {
                
                case let .success(value): result.reason = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: FlagReportResource.Resolution.self, source: sourceDictionary["resolution"] as AnyObject?) {
                
                case let .success(value): result.resolution = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["resolved"] as AnyObject?) {
                
                case let .success(value): result.resolved = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FlagReportResource", actual: "\(source)"))
            }
        }
        // Decoder for FlagResource
        Decoders.addDecoder(clazz: FlagResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FlagResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FlagResource() : instance as! FlagResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context"] as AnyObject?) {
                
                case let .success(value): result.context = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context_id"] as AnyObject?) {
                
                case let .success(value): result.contextId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["reason"] as AnyObject?) {
                
                case let .success(value): result.reason = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FlagResource", actual: "\(source)"))
            }
        }
        // Decoder for ForwardLog
        Decoders.addDecoder(clazz: ForwardLog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ForwardLog> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ForwardLog() : instance as! ForwardLog
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["end_date"] as AnyObject?) {
                
                case let .success(value): result.endDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["error_msg"] as AnyObject?) {
                
                case let .success(value): result.errorMsg = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["http_status_code"] as AnyObject?) {
                
                case let .success(value): result.httpStatusCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["payload"] as AnyObject?) {
                
                case let .success(value): result.payload = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["response"] as AnyObject?) {
                
                case let .success(value): result.response = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["retry_count"] as AnyObject?) {
                
                case let .success(value): result.retryCount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["start_date"] as AnyObject?) {
                
                case let .success(value): result.startDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): result.url = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ForwardLog", actual: "\(source)"))
            }
        }
        // Decoder for FulfillmentType
        Decoders.addDecoder(clazz: FulfillmentType.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FulfillmentType> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FulfillmentType() : instance as! FulfillmentType
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["core"] as AnyObject?) {
                
                case let .success(value): result.core = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FulfillmentType", actual: "\(source)"))
            }
        }
        // Decoder for GlobalCheckAndIncrementResource
        Decoders.addDecoder(clazz: GlobalCheckAndIncrementResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GlobalCheckAndIncrementResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? GlobalCheckAndIncrementResource() : instance as! GlobalCheckAndIncrementResource
                switch Decoders.decodeOptional(clazz: ExpressionResource.self, source: sourceDictionary["check_value_resource"] as AnyObject?) {
                
                case let .success(value): result.checkValueResource = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: ExpressionResource.self, source: sourceDictionary["global_resource"] as AnyObject?) {
                
                case let .success(value): result.globalResource = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "GlobalCheckAndIncrementResource", actual: "\(source)"))
            }
        }
        // Decoder for GlobalResource
        Decoders.addDecoder(clazz: GlobalResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GlobalResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? GlobalResource() : instance as! GlobalResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["global_def_id"] as AnyObject?) {
                
                case let .success(value): result.globalDefId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:ExpressionResource].self, source: sourceDictionary["scopes"] as AnyObject?) {
                
                case let .success(value): result.scopes = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "GlobalResource", actual: "\(source)"))
            }
        }
        // Decoder for GooglePaymentRequest
        Decoders.addDecoder(clazz: GooglePaymentRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GooglePaymentRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? GooglePaymentRequest() : instance as! GooglePaymentRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["json_payload"] as AnyObject?) {
                
                case let .success(value): result.jsonPayload = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["signature"] as AnyObject?) {
                
                case let .success(value): result.signature = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "GooglePaymentRequest", actual: "\(source)"))
            }
        }
        // Decoder for GoogleToken
        Decoders.addDecoder(clazz: GoogleToken.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GoogleToken> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? GoogleToken() : instance as! GoogleToken
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["authorization_code"] as AnyObject?) {
                
                case let .success(value): result.authorizationCode = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "GoogleToken", actual: "\(source)"))
            }
        }
        // Decoder for GrantTypeResource
        Decoders.addDecoder(clazz: GrantTypeResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GrantTypeResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? GrantTypeResource() : instance as! GrantTypeResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "GrantTypeResource", actual: "\(source)"))
            }
        }
        // Decoder for GroupMemberResource
        Decoders.addDecoder(clazz: GroupMemberResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GroupMemberResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? GroupMemberResource() : instance as! GroupMemberResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["avatar_url"] as AnyObject?) {
                
                case let .success(value): result.avatarUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display_name"] as AnyObject?) {
                
                case let .success(value): result.displayName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: GroupMemberResource.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "GroupMemberResource", actual: "\(source)"))
            }
        }
        // Decoder for GroupResource
        Decoders.addDecoder(clazz: GroupResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GroupResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? GroupResource() : instance as! GroupResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["member_count"] as AnyObject?) {
                
                case let .success(value): result.memberCount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message_of_the_day"] as AnyObject?) {
                
                case let .success(value): result.messageOfTheDay = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                
                case let .success(value): result.parent = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: GroupResource.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sub_member_count"] as AnyObject?) {
                
                case let .success(value): result.subMemberCount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_name"] as AnyObject?) {
                
                case let .success(value): result.uniqueName = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "GroupResource", actual: "\(source)"))
            }
        }
        // Decoder for IOConfig
        Decoders.addDecoder(clazz: IOConfig.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IOConfig> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? IOConfig() : instance as! IOConfig
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer"] as AnyObject?) {
                
                case let .success(value): result.customer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["enabled"] as AnyObject?) {
                
                case let .success(value): result.enabled = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["environment"] as AnyObject?) {
                
                case let .success(value): result.environment = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["product"] as AnyObject?) {
                
                case let .success(value): result.product = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "IOConfig", actual: "\(source)"))
            }
        }
        // Decoder for ImportJobOutputResource
        Decoders.addDecoder(clazz: ImportJobOutputResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ImportJobOutputResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ImportJobOutputResource() : instance as! ImportJobOutputResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["line_number"] as AnyObject?) {
                
                case let .success(value): result.lineNumber = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ImportJobOutputResource", actual: "\(source)"))
            }
        }
        // Decoder for ImportJobResource
        Decoders.addDecoder(clazz: ImportJobResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ImportJobResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ImportJobResource() : instance as! ImportJobResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["category_id"] as AnyObject?) {
                
                case let .success(value): result.categoryId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [ImportJobOutputResource].self, source: sourceDictionary["output"] as AnyObject?) {
                
                case let .success(value): result.output = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["record_count"] as AnyObject?) {
                
                case let .success(value): result.recordCount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: ImportJobResource.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): result.url = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vendor"] as AnyObject?) {
                
                case let .success(value): result.vendor = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ImportJobResource", actual: "\(source)"))
            }
        }
        // Decoder for IntWrapper
        Decoders.addDecoder(clazz: IntWrapper.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IntWrapper> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? IntWrapper() : instance as! IntWrapper
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "IntWrapper", actual: "\(source)"))
            }
        }
        // Decoder for IntegerOperationResource
        Decoders.addDecoder(clazz: IntegerOperationResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IntegerOperationResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? IntegerOperationResource() : instance as! IntegerOperationResource
                switch Decoders.decodeOptional(clazz: [ExpressionResource].self, source: sourceDictionary["args"] as AnyObject?) {
                
                case let .success(value): result.args = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["op"] as AnyObject?) {
                
                case let .success(value): result.op = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "IntegerOperationResource", actual: "\(source)"))
            }
        }
        // Decoder for InventorySubscriptionResource
        Decoders.addDecoder(clazz: InventorySubscriptionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InventorySubscriptionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? InventorySubscriptionResource() : instance as! InventorySubscriptionResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["bill_date"] as AnyObject?) {
                
                case let .success(value): result.billDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["credit"] as AnyObject?) {
                
                case let .success(value): result.credit = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [SubscriptionCreditResource].self, source: sourceDictionary["credit_log"] as AnyObject?) {
                
                case let .success(value): result.creditLog = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["grace_end"] as AnyObject?) {
                
                case let .success(value): result.graceEnd = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["inventory_id"] as AnyObject?) {
                
                case let .success(value): result.inventoryId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: InventorySubscriptionResource.InventoryStatus.self, source: sourceDictionary["inventory_status"] as AnyObject?) {
                
                case let .success(value): result.inventoryStatus = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["item_id"] as AnyObject?) {
                
                case let .success(value): result.itemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: PaymentMethodResource.self, source: sourceDictionary["payment_method"] as AnyObject?) {
                
                case let .success(value): result.paymentMethod = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["price_override"] as AnyObject?) {
                
                case let .success(value): result.priceOverride = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["price_override_reason"] as AnyObject?) {
                
                case let .success(value): result.priceOverrideReason = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["recurring_price"] as AnyObject?) {
                
                case let .success(value): result.recurringPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["start_date"] as AnyObject?) {
                
                case let .success(value): result.startDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["subscription_status"] as AnyObject?) {
                
                case let .success(value): result.subscriptionStatus = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "InventorySubscriptionResource", actual: "\(source)"))
            }
        }
        // Decoder for InvoiceCreateRequest
        Decoders.addDecoder(clazz: InvoiceCreateRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InvoiceCreateRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? InvoiceCreateRequest() : instance as! InvoiceCreateRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cart_guid"] as AnyObject?) {
                
                case let .success(value): result.cartGuid = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "InvoiceCreateRequest", actual: "\(source)"))
            }
        }
        // Decoder for InvoiceItemResource
        Decoders.addDecoder(clazz: InvoiceItemResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InvoiceItemResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? InvoiceItemResource() : instance as! InvoiceItemResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bundle_sku"] as AnyObject?) {
                
                case let .success(value): result.bundleSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["current_fulfillment_status"] as AnyObject?) {
                
                case let .success(value): result.currentFulfillmentStatus = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["item_id"] as AnyObject?) {
                
                case let .success(value): result.itemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["item_name"] as AnyObject?) {
                
                case let .success(value): result.itemName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["original_total_price"] as AnyObject?) {
                
                case let .success(value): result.originalTotalPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["original_unit_price"] as AnyObject?) {
                
                case let .success(value): result.originalUnitPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["qty"] as AnyObject?) {
                
                case let .success(value): result.qty = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sale_name"] as AnyObject?) {
                
                case let .success(value): result.saleName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku_description"] as AnyObject?) {
                
                case let .success(value): result.skuDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["system_price"] as AnyObject?) {
                
                case let .success(value): result.systemPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["total_price"] as AnyObject?) {
                
                case let .success(value): result.totalPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["unit_price"] as AnyObject?) {
                
                case let .success(value): result.unitPrice = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "InvoiceItemResource", actual: "\(source)"))
            }
        }
        // Decoder for InvoiceLogEntry
        Decoders.addDecoder(clazz: InvoiceLogEntry.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InvoiceLogEntry> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? InvoiceLogEntry() : instance as! InvoiceLogEntry
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["date"] as AnyObject?) {
                
                case let .success(value): result.date = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): result.message = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "InvoiceLogEntry", actual: "\(source)"))
            }
        }
        // Decoder for InvoicePaymentStatusRequest
        Decoders.addDecoder(clazz: InvoicePaymentStatusRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InvoicePaymentStatusRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? InvoicePaymentStatusRequest() : instance as! InvoicePaymentStatusRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["payment_method_id"] as AnyObject?) {
                
                case let .success(value): result.paymentMethodId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "InvoicePaymentStatusRequest", actual: "\(source)"))
            }
        }
        // Decoder for InvoiceResource
        Decoders.addDecoder(clazz: InvoiceResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<InvoiceResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? InvoiceResource() : instance as! InvoiceResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["billing_address1"] as AnyObject?) {
                
                case let .success(value): result.billingAddress1 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["billing_address2"] as AnyObject?) {
                
                case let .success(value): result.billingAddress2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["billing_city_name"] as AnyObject?) {
                
                case let .success(value): result.billingCityName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["billing_country_name"] as AnyObject?) {
                
                case let .success(value): result.billingCountryName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["billing_full_name"] as AnyObject?) {
                
                case let .success(value): result.billingFullName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["billing_postal_code"] as AnyObject?) {
                
                case let .success(value): result.billingPostalCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["billing_state_name"] as AnyObject?) {
                
                case let .success(value): result.billingStateName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cart_id"] as AnyObject?) {
                
                case let .success(value): result.cartId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency"] as AnyObject?) {
                
                case let .success(value): result.currency = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["current_fulfillment_status"] as AnyObject?) {
                
                case let .success(value): result.currentFulfillmentStatus = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["current_payment_status"] as AnyObject?) {
                
                case let .success(value): result.currentPaymentStatus = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["discount"] as AnyObject?) {
                
                case let .success(value): result.discount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): result.email = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["external_ref"] as AnyObject?) {
                
                case let .success(value): result.externalRef = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["fed_tax"] as AnyObject?) {
                
                case let .success(value): result.fedTax = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["grand_total"] as AnyObject?) {
                
                case let .success(value): result.grandTotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["invoice_number"] as AnyObject?) {
                
                case let .success(value): result.invoiceNumber = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [InvoiceItemResource].self, source: sourceDictionary["items"] as AnyObject?) {
                
                case let .success(value): result.items = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name_prefix"] as AnyObject?) {
                
                case let .success(value): result.namePrefix = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["order_notes"] as AnyObject?) {
                
                case let .success(value): result.orderNotes = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["parent_invoice_id"] as AnyObject?) {
                
                case let .success(value): result.parentInvoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["payment_method_id"] as AnyObject?) {
                
                case let .success(value): result.paymentMethodId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?) {
                
                case let .success(value): result.phone = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone_number"] as AnyObject?) {
                
                case let .success(value): result.phoneNumber = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["shipping"] as AnyObject?) {
                
                case let .success(value): result.shipping = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shipping_address1"] as AnyObject?) {
                
                case let .success(value): result.shippingAddress1 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shipping_address2"] as AnyObject?) {
                
                case let .success(value): result.shippingAddress2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shipping_city_name"] as AnyObject?) {
                
                case let .success(value): result.shippingCityName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shipping_country_name"] as AnyObject?) {
                
                case let .success(value): result.shippingCountryName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shipping_full_name"] as AnyObject?) {
                
                case let .success(value): result.shippingFullName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shipping_postal_code"] as AnyObject?) {
                
                case let .success(value): result.shippingPostalCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shipping_state_name"] as AnyObject?) {
                
                case let .success(value): result.shippingStateName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["state_tax"] as AnyObject?) {
                
                case let .success(value): result.stateTax = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["subtotal"] as AnyObject?) {
                
                case let .success(value): result.subtotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vendor_id"] as AnyObject?) {
                
                case let .success(value): result.vendorId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vendor_name"] as AnyObject?) {
                
                case let .success(value): result.vendorName = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "InvoiceResource", actual: "\(source)"))
            }
        }
        // Decoder for Item
        Decoders.addDecoder(clazz: Item.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Item> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                // Check discriminator to support inheritance
                if let discriminator = sourceDictionary["type_hint"] as? String, instance == nil && discriminator != "Item"{
                    return Decoders.decode(clazz: Item.self, discriminator: discriminator, source: source)
                }
                let result = instance == nil ? Item() : instance as! Item
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Behavior].self, source: sourceDictionary["behaviors"] as AnyObject?) {
                
                case let .success(value): result.behaviors = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Item", actual: "\(source)"))
            }
        }
        // Decoder for ItemBehaviorDefinitionResource
        Decoders.addDecoder(clazz: ItemBehaviorDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ItemBehaviorDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ItemBehaviorDefinitionResource() : instance as! ItemBehaviorDefinitionResource
                switch Decoders.decodeOptional(clazz: Behavior.self, source: sourceDictionary["behavior"] as AnyObject?) {
                
                case let .success(value): result.behavior = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["modifiable"] as AnyObject?) {
                
                case let .success(value): result.modifiable = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ItemBehaviorDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for ItemTemplateResource
        Decoders.addDecoder(clazz: ItemTemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ItemTemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ItemTemplateResource() : instance as! ItemTemplateResource
                switch Decoders.decodeOptional(clazz: [ItemBehaviorDefinitionResource].self, source: sourceDictionary["behaviors"] as AnyObject?) {
                
                case let .success(value): result.behaviors = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PropertyDefinitionResource].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): result.properties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ItemTemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for KeyValuePairstringstring
        Decoders.addDecoder(clazz: KeyValuePairstringstring.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<KeyValuePairstringstring> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? KeyValuePairstringstring() : instance as! KeyValuePairstringstring
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["key"] as AnyObject?) {
                
                case let .success(value): result.key = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "KeyValuePairstringstring", actual: "\(source)"))
            }
        }
        // Decoder for LeaderboardEntryResource
        Decoders.addDecoder(clazz: LeaderboardEntryResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LeaderboardEntryResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LeaderboardEntryResource() : instance as! LeaderboardEntryResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["rank"] as AnyObject?) {
                
                case let .success(value): result.rank = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["score"] as AnyObject?) {
                
                case let .success(value): result.score = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LeaderboardEntryResource", actual: "\(source)"))
            }
        }
        // Decoder for LeaderboardResource
        Decoders.addDecoder(clazz: LeaderboardResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LeaderboardResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LeaderboardResource() : instance as! LeaderboardResource
                switch Decoders.decodeOptional(clazz: [LeaderboardEntryResource].self, source: sourceDictionary["entries"] as AnyObject?) {
                
                case let .success(value): result.entries = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["strategy"] as AnyObject?) {
                
                case let .success(value): result.strategy = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LeaderboardResource", actual: "\(source)"))
            }
        }
        // Decoder for LevelingResource
        Decoders.addDecoder(clazz: LevelingResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LevelingResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LevelingResource() : instance as! LevelingResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [TierResource].self, source: sourceDictionary["tiers"] as AnyObject?) {
                
                case let .success(value): result.tiers = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LevelingResource", actual: "\(source)"))
            }
        }
        // Decoder for LimitedGettableGroup
        Decoders.addDecoder(clazz: LimitedGettableGroup.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LimitedGettableGroup> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LimitedGettableGroup() : instance as! LimitedGettableGroup
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active_only"] as AnyObject?) {
                
                case let .success(value): result.activeOnly = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["owned_limit"] as AnyObject?) {
                
                case let .success(value): result.ownedLimit = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LimitedGettableGroup", actual: "\(source)"))
            }
        }
        // Decoder for Localizer
        Decoders.addDecoder(clazz: Localizer.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Localizer> in
            if let source = source as? Any {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias Localizer", actual: "\(source)"))
            }
        }
        // Decoder for LocationLogResource
        Decoders.addDecoder(clazz: LocationLogResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LocationLogResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LocationLogResource() : instance as! LocationLogResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                
                case let .success(value): result.country = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ip"] as AnyObject?) {
                
                case let .success(value): result.ip = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["time"] as AnyObject?) {
                
                case let .success(value): result.time = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LocationLogResource", actual: "\(source)"))
            }
        }
        // Decoder for LookupResource
        Decoders.addDecoder(clazz: LookupResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LookupResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LookupResource() : instance as! LookupResource
                switch Decoders.decodeOptional(clazz: ExpressionResource.self, source: sourceDictionary["lookup_key"] as AnyObject?) {
                
                case let .success(value): result.lookupKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value_type"] as AnyObject?) {
                
                case let .success(value): result.valueType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LookupResource", actual: "\(source)"))
            }
        }
        // Decoder for LookupTypeResource
        Decoders.addDecoder(clazz: LookupTypeResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LookupTypeResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LookupTypeResource() : instance as! LookupTypeResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["key_type"] as AnyObject?) {
                
                case let .success(value): result.keyType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value_type"] as AnyObject?) {
                
                case let .success(value): result.valueType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LookupTypeResource", actual: "\(source)"))
            }
        }
        // Decoder for Maintenance
        Decoders.addDecoder(clazz: Maintenance.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Maintenance> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Maintenance() : instance as! Maintenance
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["access_locked"] as AnyObject?) {
                
                case let .success(value): result.accessLocked = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["details"] as AnyObject?) {
                
                case let .success(value): result.details = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                
                case let .success(value): result.message = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Maintenance", actual: "\(source)"))
            }
        }
        // Decoder for MapResource
        Decoders.addDecoder(clazz: MapResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MapResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? MapResource() : instance as! MapResource
                switch Decoders.decodeOptional(clazz: [String:ExpressionResource].self, source: sourceDictionary["map"] as AnyObject?) {
                
                case let .success(value): result.map = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "MapResource", actual: "\(source)"))
            }
        }
        // Decoder for Mapstringobject
        Decoders.addDecoder(clazz: Mapstringobject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Mapstringobject> in
            if let source = source as? Any {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias Mapstringobject", actual: "\(source)"))
            }
        }
        // Decoder for MetricResource
        Decoders.addDecoder(clazz: MetricResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MetricResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? MetricResource() : instance as! MetricResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["activity_occurence_id"] as AnyObject?) {
                
                case let .success(value): result.activityOccurenceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "MetricResource", actual: "\(source)"))
            }
        }
        // Decoder for MongoDatabaseConfig
        Decoders.addDecoder(clazz: MongoDatabaseConfig.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MongoDatabaseConfig> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? MongoDatabaseConfig() : instance as! MongoDatabaseConfig
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["db_name"] as AnyObject?) {
                
                case let .success(value): result.dbName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["options"] as AnyObject?) {
                
                case let .success(value): result.options = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                
                case let .success(value): result.password = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["servers"] as AnyObject?) {
                
                case let .success(value): result.servers = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "MongoDatabaseConfig", actual: "\(source)"))
            }
        }
        // Decoder for NestedCategory
        Decoders.addDecoder(clazz: NestedCategory.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<NestedCategory> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? NestedCategory() : instance as! NestedCategory
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): result.active = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "NestedCategory", actual: "\(source)"))
            }
        }
        // Decoder for NewPasswordRequest
        Decoders.addDecoder(clazz: NewPasswordRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<NewPasswordRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? NewPasswordRequest() : instance as! NewPasswordRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                
                case let .success(value): result.password = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["secret"] as AnyObject?) {
                
                case let .success(value): result.secret = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "NewPasswordRequest", actual: "\(source)"))
            }
        }
        // Decoder for OAuth2Resource
        Decoders.addDecoder(clazz: OAuth2Resource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OAuth2Resource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? OAuth2Resource() : instance as! OAuth2Resource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["access_token"] as AnyObject?) {
                
                case let .success(value): result.accessToken = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["expires_in"] as AnyObject?) {
                
                case let .success(value): result.expiresIn = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["scope"] as AnyObject?) {
                
                case let .success(value): result.scope = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token_type"] as AnyObject?) {
                
                case let .success(value): result.tokenType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "OAuth2Resource", actual: "\(source)"))
            }
        }
        // Decoder for OauthAccessTokenResource
        Decoders.addDecoder(clazz: OauthAccessTokenResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OauthAccessTokenResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? OauthAccessTokenResource() : instance as! OauthAccessTokenResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client_id"] as AnyObject?) {
                
                case let .success(value): result.clientId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?) {
                
                case let .success(value): result.token = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "OauthAccessTokenResource", actual: "\(source)"))
            }
        }
        // Decoder for Operator
        Decoders.addDecoder(clazz: Operator.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Operator> in
            if let source = source as? Any {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias Operator", actual: "\(source)"))
            }
        }
        // Decoder for OptimalPaymentRequest
        Decoders.addDecoder(clazz: OptimalPaymentRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OptimalPaymentRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? OptimalPaymentRequest() : instance as! OptimalPaymentRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): result.email = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["first_name"] as AnyObject?) {
                
                case let .success(value): result.firstName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_name"] as AnyObject?) {
                
                case let .success(value): result.lastName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["on_decline"] as AnyObject?) {
                
                case let .success(value): result.onDecline = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["on_error"] as AnyObject?) {
                
                case let .success(value): result.onError = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["on_success"] as AnyObject?) {
                
                case let .success(value): result.onSuccess = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "OptimalPaymentRequest", actual: "\(source)"))
            }
        }
        // Decoder for Order
        Decoders.addDecoder(clazz: Order.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Order> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Order() : instance as! Order
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["ascending"] as AnyObject?) {
                
                case let .success(value): result.ascending = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["descending"] as AnyObject?) {
                
                case let .success(value): result.descending = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Order.Direction.self, source: sourceDictionary["direction"] as AnyObject?) {
                
                case let .success(value): result.direction = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["ignore_case"] as AnyObject?) {
                
                case let .success(value): result.ignoreCase = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Order.NullHandling.self, source: sourceDictionary["null_handling"] as AnyObject?) {
                
                case let .success(value): result.nullHandling = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?) {
                
                case let .success(value): result.property = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Order", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceAchievementDefinitionResource
        Decoders.addDecoder(clazz: PageResourceAchievementDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceAchievementDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceAchievementDefinitionResource() : instance as! PageResourceAchievementDefinitionResource
                switch Decoders.decodeOptional(clazz: [AchievementDefinitionResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceAchievementDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceAggregateCountResource
        Decoders.addDecoder(clazz: PageResourceAggregateCountResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceAggregateCountResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceAggregateCountResource() : instance as! PageResourceAggregateCountResource
                switch Decoders.decodeOptional(clazz: [AggregateCountResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceAggregateCountResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceAggregateInvoiceReportResource
        Decoders.addDecoder(clazz: PageResourceAggregateInvoiceReportResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceAggregateInvoiceReportResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceAggregateInvoiceReportResource() : instance as! PageResourceAggregateInvoiceReportResource
                switch Decoders.decodeOptional(clazz: [AggregateInvoiceReportResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceAggregateInvoiceReportResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceArticleResource
        Decoders.addDecoder(clazz: PageResourceArticleResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceArticleResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceArticleResource() : instance as! PageResourceArticleResource
                switch Decoders.decodeOptional(clazz: [ArticleResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceArticleResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceArtistResource
        Decoders.addDecoder(clazz: PageResourceArtistResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceArtistResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceArtistResource() : instance as! PageResourceArtistResource
                switch Decoders.decodeOptional(clazz: [ArtistResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceArtistResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceBareActivityResource
        Decoders.addDecoder(clazz: PageResourceBareActivityResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceBareActivityResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceBareActivityResource() : instance as! PageResourceBareActivityResource
                switch Decoders.decodeOptional(clazz: [BareActivityResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceBareActivityResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceBareChallengeActivityResource
        Decoders.addDecoder(clazz: PageResourceBareChallengeActivityResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceBareChallengeActivityResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceBareChallengeActivityResource() : instance as! PageResourceBareChallengeActivityResource
                switch Decoders.decodeOptional(clazz: [BareChallengeActivityResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceBareChallengeActivityResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceBillingReport
        Decoders.addDecoder(clazz: PageResourceBillingReport.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceBillingReport> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceBillingReport() : instance as! PageResourceBillingReport
                switch Decoders.decodeOptional(clazz: [BillingReport].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceBillingReport", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceBreCategoryResource
        Decoders.addDecoder(clazz: PageResourceBreCategoryResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceBreCategoryResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceBreCategoryResource() : instance as! PageResourceBreCategoryResource
                switch Decoders.decodeOptional(clazz: [BreCategoryResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceBreCategoryResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceBreEventLog
        Decoders.addDecoder(clazz: PageResourceBreEventLog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceBreEventLog> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceBreEventLog() : instance as! PageResourceBreEventLog
                switch Decoders.decodeOptional(clazz: [BreEventLog].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceBreEventLog", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceBreGlobalResource
        Decoders.addDecoder(clazz: PageResourceBreGlobalResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceBreGlobalResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceBreGlobalResource() : instance as! PageResourceBreGlobalResource
                switch Decoders.decodeOptional(clazz: [BreGlobalResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceBreGlobalResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceBreRule
        Decoders.addDecoder(clazz: PageResourceBreRule.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceBreRule> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceBreRule() : instance as! PageResourceBreRule
                switch Decoders.decodeOptional(clazz: [BreRule].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceBreRule", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceBreTriggerResource
        Decoders.addDecoder(clazz: PageResourceBreTriggerResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceBreTriggerResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceBreTriggerResource() : instance as! PageResourceBreTriggerResource
                switch Decoders.decodeOptional(clazz: [BreTriggerResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceBreTriggerResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceCampaignResource
        Decoders.addDecoder(clazz: PageResourceCampaignResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceCampaignResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceCampaignResource() : instance as! PageResourceCampaignResource
                switch Decoders.decodeOptional(clazz: [CampaignResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceCampaignResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceCartSummary
        Decoders.addDecoder(clazz: PageResourceCartSummary.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceCartSummary> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceCartSummary() : instance as! PageResourceCartSummary
                switch Decoders.decodeOptional(clazz: [CartSummary].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceCartSummary", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceCatalogSale
        Decoders.addDecoder(clazz: PageResourceCatalogSale.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceCatalogSale> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceCatalogSale() : instance as! PageResourceCatalogSale
                switch Decoders.decodeOptional(clazz: [CatalogSale].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceCatalogSale", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceCategoryResource
        Decoders.addDecoder(clazz: PageResourceCategoryResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceCategoryResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceCategoryResource() : instance as! PageResourceCategoryResource
                switch Decoders.decodeOptional(clazz: [CategoryResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceCategoryResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceChallengeEventParticipantResource
        Decoders.addDecoder(clazz: PageResourceChallengeEventParticipantResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceChallengeEventParticipantResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceChallengeEventParticipantResource() : instance as! PageResourceChallengeEventParticipantResource
                switch Decoders.decodeOptional(clazz: [ChallengeEventParticipantResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceChallengeEventParticipantResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceChallengeEventResource
        Decoders.addDecoder(clazz: PageResourceChallengeEventResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceChallengeEventResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceChallengeEventResource() : instance as! PageResourceChallengeEventResource
                switch Decoders.decodeOptional(clazz: [ChallengeEventResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceChallengeEventResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceChallengeResource
        Decoders.addDecoder(clazz: PageResourceChallengeResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceChallengeResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceChallengeResource() : instance as! PageResourceChallengeResource
                switch Decoders.decodeOptional(clazz: [ChallengeResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceChallengeResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceClientResource
        Decoders.addDecoder(clazz: PageResourceClientResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceClientResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceClientResource() : instance as! PageResourceClientResource
                switch Decoders.decodeOptional(clazz: [ClientResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceClientResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceCommentResource
        Decoders.addDecoder(clazz: PageResourceCommentResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceCommentResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceCommentResource() : instance as! PageResourceCommentResource
                switch Decoders.decodeOptional(clazz: [CommentResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceCommentResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceConfig
        Decoders.addDecoder(clazz: PageResourceConfig.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceConfig> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceConfig() : instance as! PageResourceConfig
                switch Decoders.decodeOptional(clazz: [Config].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceConfig", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceCountryTaxResource
        Decoders.addDecoder(clazz: PageResourceCountryTaxResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceCountryTaxResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceCountryTaxResource() : instance as! PageResourceCountryTaxResource
                switch Decoders.decodeOptional(clazz: [CountryTaxResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceCountryTaxResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceCurrencyResource
        Decoders.addDecoder(clazz: PageResourceCurrencyResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceCurrencyResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceCurrencyResource() : instance as! PageResourceCurrencyResource
                switch Decoders.decodeOptional(clazz: [CurrencyResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceCurrencyResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceDeviceResource
        Decoders.addDecoder(clazz: PageResourceDeviceResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceDeviceResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceDeviceResource() : instance as! PageResourceDeviceResource
                switch Decoders.decodeOptional(clazz: [DeviceResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceDeviceResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceDispositionResource
        Decoders.addDecoder(clazz: PageResourceDispositionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceDispositionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceDispositionResource() : instance as! PageResourceDispositionResource
                switch Decoders.decodeOptional(clazz: [DispositionResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceDispositionResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceEntitlementItem
        Decoders.addDecoder(clazz: PageResourceEntitlementItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceEntitlementItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceEntitlementItem() : instance as! PageResourceEntitlementItem
                switch Decoders.decodeOptional(clazz: [EntitlementItem].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceEntitlementItem", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceFlagReportResource
        Decoders.addDecoder(clazz: PageResourceFlagReportResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceFlagReportResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceFlagReportResource() : instance as! PageResourceFlagReportResource
                switch Decoders.decodeOptional(clazz: [FlagReportResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceFlagReportResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceForwardLog
        Decoders.addDecoder(clazz: PageResourceForwardLog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceForwardLog> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceForwardLog() : instance as! PageResourceForwardLog
                switch Decoders.decodeOptional(clazz: [ForwardLog].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceForwardLog", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceFulfillmentType
        Decoders.addDecoder(clazz: PageResourceFulfillmentType.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceFulfillmentType> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceFulfillmentType() : instance as! PageResourceFulfillmentType
                switch Decoders.decodeOptional(clazz: [FulfillmentType].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceFulfillmentType", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceGroupMemberResource
        Decoders.addDecoder(clazz: PageResourceGroupMemberResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceGroupMemberResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceGroupMemberResource() : instance as! PageResourceGroupMemberResource
                switch Decoders.decodeOptional(clazz: [GroupMemberResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceGroupMemberResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceGroupResource
        Decoders.addDecoder(clazz: PageResourceGroupResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceGroupResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceGroupResource() : instance as! PageResourceGroupResource
                switch Decoders.decodeOptional(clazz: [GroupResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceGroupResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceImportJobResource
        Decoders.addDecoder(clazz: PageResourceImportJobResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceImportJobResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceImportJobResource() : instance as! PageResourceImportJobResource
                switch Decoders.decodeOptional(clazz: [ImportJobResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceImportJobResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceInvoiceLogEntry
        Decoders.addDecoder(clazz: PageResourceInvoiceLogEntry.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceInvoiceLogEntry> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceInvoiceLogEntry() : instance as! PageResourceInvoiceLogEntry
                switch Decoders.decodeOptional(clazz: [InvoiceLogEntry].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceInvoiceLogEntry", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceInvoiceResource
        Decoders.addDecoder(clazz: PageResourceInvoiceResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceInvoiceResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceInvoiceResource() : instance as! PageResourceInvoiceResource
                switch Decoders.decodeOptional(clazz: [InvoiceResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceInvoiceResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceItemTemplateResource
        Decoders.addDecoder(clazz: PageResourceItemTemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceItemTemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceItemTemplateResource() : instance as! PageResourceItemTemplateResource
                switch Decoders.decodeOptional(clazz: [ItemTemplateResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceItemTemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceLevelingResource
        Decoders.addDecoder(clazz: PageResourceLevelingResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceLevelingResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceLevelingResource() : instance as! PageResourceLevelingResource
                switch Decoders.decodeOptional(clazz: [LevelingResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceLevelingResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceLocationLogResource
        Decoders.addDecoder(clazz: PageResourceLocationLogResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceLocationLogResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceLocationLogResource() : instance as! PageResourceLocationLogResource
                switch Decoders.decodeOptional(clazz: [LocationLogResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceLocationLogResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceMapstringobject
        Decoders.addDecoder(clazz: PageResourceMapstringobject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceMapstringobject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceMapstringobject() : instance as! PageResourceMapstringobject
                switch Decoders.decodeOptional(clazz: [Mapstringobject].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceMapstringobject", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceOauthAccessTokenResource
        Decoders.addDecoder(clazz: PageResourceOauthAccessTokenResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceOauthAccessTokenResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceOauthAccessTokenResource() : instance as! PageResourceOauthAccessTokenResource
                switch Decoders.decodeOptional(clazz: [OauthAccessTokenResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceOauthAccessTokenResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourcePermissionResource
        Decoders.addDecoder(clazz: PageResourcePermissionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourcePermissionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourcePermissionResource() : instance as! PageResourcePermissionResource
                switch Decoders.decodeOptional(clazz: [PermissionResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourcePermissionResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourcePollResource
        Decoders.addDecoder(clazz: PageResourcePollResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourcePollResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourcePollResource() : instance as! PageResourcePollResource
                switch Decoders.decodeOptional(clazz: [PollResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourcePollResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceQuestionResource
        Decoders.addDecoder(clazz: PageResourceQuestionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceQuestionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceQuestionResource() : instance as! PageResourceQuestionResource
                switch Decoders.decodeOptional(clazz: [QuestionResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceQuestionResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceQuestionTemplateResource
        Decoders.addDecoder(clazz: PageResourceQuestionTemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceQuestionTemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceQuestionTemplateResource() : instance as! PageResourceQuestionTemplateResource
                switch Decoders.decodeOptional(clazz: [QuestionTemplateResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceQuestionTemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceRevenueCountryReportResource
        Decoders.addDecoder(clazz: PageResourceRevenueCountryReportResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceRevenueCountryReportResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceRevenueCountryReportResource() : instance as! PageResourceRevenueCountryReportResource
                switch Decoders.decodeOptional(clazz: [RevenueCountryReportResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceRevenueCountryReportResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceRevenueProductReportResource
        Decoders.addDecoder(clazz: PageResourceRevenueProductReportResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceRevenueProductReportResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceRevenueProductReportResource() : instance as! PageResourceRevenueProductReportResource
                switch Decoders.decodeOptional(clazz: [RevenueProductReportResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceRevenueProductReportResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceRewardSetResource
        Decoders.addDecoder(clazz: PageResourceRewardSetResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceRewardSetResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceRewardSetResource() : instance as! PageResourceRewardSetResource
                switch Decoders.decodeOptional(clazz: [RewardSetResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceRewardSetResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceRoleResource
        Decoders.addDecoder(clazz: PageResourceRoleResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceRoleResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceRoleResource() : instance as! PageResourceRoleResource
                switch Decoders.decodeOptional(clazz: [RoleResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceRoleResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceSavedAddressResource
        Decoders.addDecoder(clazz: PageResourceSavedAddressResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceSavedAddressResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceSavedAddressResource() : instance as! PageResourceSavedAddressResource
                switch Decoders.decodeOptional(clazz: [SavedAddressResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceSavedAddressResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceSimpleReferenceResourceobject
        Decoders.addDecoder(clazz: PageResourceSimpleReferenceResourceobject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceSimpleReferenceResourceobject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceSimpleReferenceResourceobject() : instance as! PageResourceSimpleReferenceResourceobject
                switch Decoders.decodeOptional(clazz: [SimpleReferenceResourceobject].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceSimpleReferenceResourceobject", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceSimpleUserResource
        Decoders.addDecoder(clazz: PageResourceSimpleUserResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceSimpleUserResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceSimpleUserResource() : instance as! PageResourceSimpleUserResource
                switch Decoders.decodeOptional(clazz: [SimpleUserResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceSimpleUserResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceSimpleWallet
        Decoders.addDecoder(clazz: PageResourceSimpleWallet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceSimpleWallet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceSimpleWallet() : instance as! PageResourceSimpleWallet
                switch Decoders.decodeOptional(clazz: [SimpleWallet].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceSimpleWallet", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceStateTaxResource
        Decoders.addDecoder(clazz: PageResourceStateTaxResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceStateTaxResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceStateTaxResource() : instance as! PageResourceStateTaxResource
                switch Decoders.decodeOptional(clazz: [StateTaxResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceStateTaxResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceStoreItem
        Decoders.addDecoder(clazz: PageResourceStoreItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceStoreItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceStoreItem() : instance as! PageResourceStoreItem
                switch Decoders.decodeOptional(clazz: [StoreItem].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceStoreItem", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceStoreItemTemplateResource
        Decoders.addDecoder(clazz: PageResourceStoreItemTemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceStoreItemTemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceStoreItemTemplateResource() : instance as! PageResourceStoreItemTemplateResource
                switch Decoders.decodeOptional(clazz: [StoreItemTemplateResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceStoreItemTemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceSubscriptionResource
        Decoders.addDecoder(clazz: PageResourceSubscriptionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceSubscriptionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceSubscriptionResource() : instance as! PageResourceSubscriptionResource
                switch Decoders.decodeOptional(clazz: [SubscriptionResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceSubscriptionResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceSubscriptionTemplateResource
        Decoders.addDecoder(clazz: PageResourceSubscriptionTemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceSubscriptionTemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceSubscriptionTemplateResource() : instance as! PageResourceSubscriptionTemplateResource
                switch Decoders.decodeOptional(clazz: [SubscriptionTemplateResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceSubscriptionTemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceTemplateResource
        Decoders.addDecoder(clazz: PageResourceTemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceTemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceTemplateResource() : instance as! PageResourceTemplateResource
                switch Decoders.decodeOptional(clazz: [TemplateResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceTemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceTransactionResource
        Decoders.addDecoder(clazz: PageResourceTransactionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceTransactionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceTransactionResource() : instance as! PageResourceTransactionResource
                switch Decoders.decodeOptional(clazz: [TransactionResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceTransactionResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceUsageInfo
        Decoders.addDecoder(clazz: PageResourceUsageInfo.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceUsageInfo> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceUsageInfo() : instance as! PageResourceUsageInfo
                switch Decoders.decodeOptional(clazz: [UsageInfo].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceUsageInfo", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceUserAchievementGroupResource
        Decoders.addDecoder(clazz: PageResourceUserAchievementGroupResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceUserAchievementGroupResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceUserAchievementGroupResource() : instance as! PageResourceUserAchievementGroupResource
                switch Decoders.decodeOptional(clazz: [UserAchievementGroupResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceUserAchievementGroupResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceUserActionLog
        Decoders.addDecoder(clazz: PageResourceUserActionLog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceUserActionLog> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceUserActionLog() : instance as! PageResourceUserActionLog
                switch Decoders.decodeOptional(clazz: [UserActionLog].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceUserActionLog", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceUserBaseResource
        Decoders.addDecoder(clazz: PageResourceUserBaseResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceUserBaseResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceUserBaseResource() : instance as! PageResourceUserBaseResource
                switch Decoders.decodeOptional(clazz: [UserBaseResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceUserBaseResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceUserInventoryResource
        Decoders.addDecoder(clazz: PageResourceUserInventoryResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceUserInventoryResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceUserInventoryResource() : instance as! PageResourceUserInventoryResource
                switch Decoders.decodeOptional(clazz: [UserInventoryResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceUserInventoryResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceUserItemLogResource
        Decoders.addDecoder(clazz: PageResourceUserItemLogResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceUserItemLogResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceUserItemLogResource() : instance as! PageResourceUserItemLogResource
                switch Decoders.decodeOptional(clazz: [UserItemLogResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceUserItemLogResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceUserLevelingResource
        Decoders.addDecoder(clazz: PageResourceUserLevelingResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceUserLevelingResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceUserLevelingResource() : instance as! PageResourceUserLevelingResource
                switch Decoders.decodeOptional(clazz: [UserLevelingResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceUserLevelingResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceUserRelationshipResource
        Decoders.addDecoder(clazz: PageResourceUserRelationshipResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceUserRelationshipResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceUserRelationshipResource() : instance as! PageResourceUserRelationshipResource
                switch Decoders.decodeOptional(clazz: [UserRelationshipResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceUserRelationshipResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceVendorResource
        Decoders.addDecoder(clazz: PageResourceVendorResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceVendorResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceVendorResource() : instance as! PageResourceVendorResource
                switch Decoders.decodeOptional(clazz: [VendorResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceVendorResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceVideoRelationshipResource
        Decoders.addDecoder(clazz: PageResourceVideoRelationshipResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceVideoRelationshipResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceVideoRelationshipResource() : instance as! PageResourceVideoRelationshipResource
                switch Decoders.decodeOptional(clazz: [VideoRelationshipResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceVideoRelationshipResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceVideoResource
        Decoders.addDecoder(clazz: PageResourceVideoResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceVideoResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceVideoResource() : instance as! PageResourceVideoResource
                switch Decoders.decodeOptional(clazz: [VideoResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceVideoResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceWalletTotalResponse
        Decoders.addDecoder(clazz: PageResourceWalletTotalResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceWalletTotalResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceWalletTotalResponse() : instance as! PageResourceWalletTotalResponse
                switch Decoders.decodeOptional(clazz: [WalletTotalResponse].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceWalletTotalResponse", actual: "\(source)"))
            }
        }
        // Decoder for PageResourceWalletTransactionResource
        Decoders.addDecoder(clazz: PageResourceWalletTransactionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourceWalletTransactionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourceWalletTransactionResource() : instance as! PageResourceWalletTransactionResource
                switch Decoders.decodeOptional(clazz: [WalletTransactionResource].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourceWalletTransactionResource", actual: "\(source)"))
            }
        }
        // Decoder for PageResourcestring
        Decoders.addDecoder(clazz: PageResourcestring.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PageResourcestring> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PageResourcestring() : instance as! PageResourcestring
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["content"] as AnyObject?) {
                
                case let .success(value): result.content = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["first"] as AnyObject?) {
                
                case let .success(value): result.first = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["last"] as AnyObject?) {
                
                case let .success(value): result.last = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number"] as AnyObject?) {
                
                case let .success(value): result.number = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["number_of_elements"] as AnyObject?) {
                
                case let .success(value): result.numberOfElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Order].self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["total_elements"] as AnyObject?) {
                
                case let .success(value): result.totalElements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["total_pages"] as AnyObject?) {
                
                case let .success(value): result.totalPages = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PageResourcestring", actual: "\(source)"))
            }
        }
        // Decoder for ParameterResource
        Decoders.addDecoder(clazz: ParameterResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ParameterResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ParameterResource() : instance as! ParameterResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["of"] as AnyObject?) {
                
                case let .success(value): result.of = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ParameterResource", actual: "\(source)"))
            }
        }
        // Decoder for PasswordResetRequest
        Decoders.addDecoder(clazz: PasswordResetRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PasswordResetRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PasswordResetRequest() : instance as! PasswordResetRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): result.email = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mobile_number"] as AnyObject?) {
                
                case let .success(value): result.mobileNumber = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PasswordResetRequest", actual: "\(source)"))
            }
        }
        // Decoder for PayBySavedMethodRequest
        Decoders.addDecoder(clazz: PayBySavedMethodRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PayBySavedMethodRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PayBySavedMethodRequest() : instance as! PayBySavedMethodRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["payment_method"] as AnyObject?) {
                
                case let .success(value): result.paymentMethod = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PayBySavedMethodRequest", actual: "\(source)"))
            }
        }
        // Decoder for PaymentAuthorizationResource
        Decoders.addDecoder(clazz: PaymentAuthorizationResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PaymentAuthorizationResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PaymentAuthorizationResource() : instance as! PaymentAuthorizationResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["captured"] as AnyObject?) {
                
                case let .success(value): result.captured = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created"] as AnyObject?) {
                
                case let .success(value): result.created = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["details"] as AnyObject?) {
                
                case let .success(value): result.details = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice"] as AnyObject?) {
                
                case let .success(value): result.invoice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleReferenceResourceint.self, source: sourceDictionary["payment_type"] as AnyObject?) {
                
                case let .success(value): result.paymentType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PaymentAuthorizationResource", actual: "\(source)"))
            }
        }
        // Decoder for PaymentMethodDetails
        Decoders.addDecoder(clazz: PaymentMethodDetails.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PaymentMethodDetails> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PaymentMethodDetails() : instance as! PaymentMethodDetails
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["default"] as AnyObject?) {
                
                case let .success(value): result._default = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["expiration_date"] as AnyObject?) {
                
                case let .success(value): result.expirationDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["expiration_month"] as AnyObject?) {
                
                case let .success(value): result.expirationMonth = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["expiration_year"] as AnyObject?) {
                
                case let .success(value): result.expirationYear = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last4"] as AnyObject?) {
                
                case let .success(value): result.last4 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["verified"] as AnyObject?) {
                
                case let .success(value): result.verified = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PaymentMethodDetails", actual: "\(source)"))
            }
        }
        // Decoder for PaymentMethodResource
        Decoders.addDecoder(clazz: PaymentMethodResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PaymentMethodResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PaymentMethodResource() : instance as! PaymentMethodResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["default"] as AnyObject?) {
                
                case let .success(value): result._default = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["disabled"] as AnyObject?) {
                
                case let .success(value): result.disabled = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["expiration_date"] as AnyObject?) {
                
                case let .success(value): result.expirationDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["expiration_month"] as AnyObject?) {
                
                case let .success(value): result.expirationMonth = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["expiration_year"] as AnyObject?) {
                
                case let .success(value): result.expirationYear = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last4"] as AnyObject?) {
                
                case let .success(value): result.last4 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: PaymentMethodTypeResource.self, source: sourceDictionary["payment_method_type"] as AnyObject?) {
                
                case let .success(value): result.paymentMethodType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: PaymentMethodResource.PaymentType.self, source: sourceDictionary["payment_type"] as AnyObject?) {
                
                case let .success(value): result.paymentType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?) {
                
                case let .success(value): result.token = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["verified"] as AnyObject?) {
                
                case let .success(value): result.verified = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PaymentMethodResource", actual: "\(source)"))
            }
        }
        // Decoder for PaymentMethodTypeResource
        Decoders.addDecoder(clazz: PaymentMethodTypeResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PaymentMethodTypeResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PaymentMethodTypeResource() : instance as! PaymentMethodTypeResource
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PaymentMethodTypeResource", actual: "\(source)"))
            }
        }
        // Decoder for PermissionResource
        Decoders.addDecoder(clazz: PermissionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PermissionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PermissionResource() : instance as! PermissionResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["locked"] as AnyObject?) {
                
                case let .success(value): result.locked = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["parent"] as AnyObject?) {
                
                case let .success(value): result.parent = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["permission"] as AnyObject?) {
                
                case let .success(value): result.permission = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PermissionResource", actual: "\(source)"))
            }
        }
        // Decoder for PollAnswerResource
        Decoders.addDecoder(clazz: PollAnswerResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PollAnswerResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PollAnswerResource() : instance as! PollAnswerResource
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["count"] as AnyObject?) {
                
                case let .success(value): result.count = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["key"] as AnyObject?) {
                
                case let .success(value): result.key = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["text"] as AnyObject?) {
                
                case let .success(value): result.text = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PollAnswerResource", actual: "\(source)"))
            }
        }
        // Decoder for PollResource
        Decoders.addDecoder(clazz: PollResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PollResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PollResource() : instance as! PollResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): result.active = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PollAnswerResource].self, source: sourceDictionary["answers"] as AnyObject?) {
                
                case let .success(value): result.answers = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: NestedCategory.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["text"] as AnyObject?) {
                
                case let .success(value): result.text = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: PollResource.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PollResource", actual: "\(source)"))
            }
        }
        // Decoder for PollResponseResource
        Decoders.addDecoder(clazz: PollResponseResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PollResponseResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PollResponseResource() : instance as! PollResponseResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["answer"] as AnyObject?) {
                
                case let .success(value): result.answer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["answered_date"] as AnyObject?) {
                
                case let .success(value): result.answeredDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["poll_id"] as AnyObject?) {
                
                case let .success(value): result.pollId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PollResponseResource", actual: "\(source)"))
            }
        }
        // Decoder for PredicateOperation
        Decoders.addDecoder(clazz: PredicateOperation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PredicateOperation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PredicateOperation() : instance as! PredicateOperation
                switch Decoders.decodeOptional(clazz: [Expressionobject].self, source: sourceDictionary["args"] as AnyObject?) {
                
                case let .success(value): result.args = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Operator.self, source: sourceDictionary["operator"] as AnyObject?) {
                
                case let .success(value): result._operator = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PredicateOperation", actual: "\(source)"))
            }
        }
        // Decoder for PredicateResource
        Decoders.addDecoder(clazz: PredicateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PredicateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PredicateResource() : instance as! PredicateResource
                switch Decoders.decodeOptional(clazz: [ExpressionResource].self, source: sourceDictionary["args"] as AnyObject?) {
                
                case let .success(value): result.args = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["op"] as AnyObject?) {
                
                case let .success(value): result.op = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PredicateResource", actual: "\(source)"))
            }
        }
        // Decoder for Property
        Decoders.addDecoder(clazz: Property.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Property> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                // Check discriminator to support inheritance
                if let discriminator = sourceDictionary["type"] as? String, instance == nil && discriminator != "Property"{
                    return Decoders.decode(clazz: Property.self, discriminator: discriminator, source: source)
                }
                let result = instance == nil ? Property() : instance as! Property
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Property", actual: "\(source)"))
            }
        }
        // Decoder for PropertyDefinitionResource
        Decoders.addDecoder(clazz: PropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                // Check discriminator to support inheritance
                if let discriminator = sourceDictionary["type"] as? String, instance == nil && discriminator != "PropertyDefinitionResource"{
                    return Decoders.decode(clazz: PropertyDefinitionResource.self, discriminator: discriminator, source: source)
                }
                let result = instance == nil ? PropertyDefinitionResource() : instance as! PropertyDefinitionResource
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for PropertyFieldListResource
        Decoders.addDecoder(clazz: PropertyFieldListResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PropertyFieldListResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PropertyFieldListResource() : instance as! PropertyFieldListResource
                switch Decoders.decodeOptional(clazz: [PropertyFieldResource].self, source: sourceDictionary["property_definition_fields"] as AnyObject?) {
                
                case let .success(value): result.propertyDefinitionFields = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PropertyFieldResource].self, source: sourceDictionary["property_fields"] as AnyObject?) {
                
                case let .success(value): result.propertyFields = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property_type"] as AnyObject?) {
                
                case let .success(value): result.propertyType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PropertyFieldListResource", actual: "\(source)"))
            }
        }
        // Decoder for PropertyFieldResource
        Decoders.addDecoder(clazz: PropertyFieldResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PropertyFieldResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PropertyFieldResource() : instance as! PropertyFieldResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldResource.InnerType.self, source: sourceDictionary["inner_type"] as AnyObject?) {
                
                case let .success(value): result.innerType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PropertyFieldResource].self, source: sourceDictionary["inner_type_fields"] as AnyObject?) {
                
                case let .success(value): result.innerTypeFields = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldResource.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["valid_values"] as AnyObject?) {
                
                case let .success(value): result.validValues = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PropertyFieldResource", actual: "\(source)"))
            }
        }
        // Decoder for QuestionResource
        Decoders.addDecoder(clazz: QuestionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<QuestionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? QuestionResource() : instance as! QuestionResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [AnswerResource].self, source: sourceDictionary["answers"] as AnyObject?) {
                
                case let .success(value): result.answers = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: NestedCategory.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["difficulty"] as AnyObject?) {
                
                case let .success(value): result.difficulty = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["import_id"] as AnyObject?) {
                
                case let .success(value): result.importId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["published_date"] as AnyObject?) {
                
                case let .success(value): result.publishedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Property.self, source: sourceDictionary["question"] as AnyObject?) {
                
                case let .success(value): result.question = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["source1"] as AnyObject?) {
                
                case let .success(value): result.source1 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["source2"] as AnyObject?) {
                
                case let .success(value): result.source2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["vendor"] as AnyObject?) {
                
                case let .success(value): result.vendor = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "QuestionResource", actual: "\(source)"))
            }
        }
        // Decoder for QuestionTemplateResource
        Decoders.addDecoder(clazz: QuestionTemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<QuestionTemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? QuestionTemplateResource() : instance as! QuestionTemplateResource
                switch Decoders.decodeOptional(clazz: PropertyDefinitionResource.self, source: sourceDictionary["answer_property"] as AnyObject?) {
                
                case let .success(value): result.answerProperty = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PropertyDefinitionResource].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): result.properties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: PropertyDefinitionResource.self, source: sourceDictionary["question_property"] as AnyObject?) {
                
                case let .success(value): result.questionProperty = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "QuestionTemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for QuickBuyRequest
        Decoders.addDecoder(clazz: QuickBuyRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<QuickBuyRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? QuickBuyRequest() : instance as! QuickBuyRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "QuickBuyRequest", actual: "\(source)"))
            }
        }
        // Decoder for RawEmailResource
        Decoders.addDecoder(clazz: RawEmailResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RawEmailResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RawEmailResource() : instance as! RawEmailResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["body"] as AnyObject?) {
                
                case let .success(value): result.body = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["from"] as AnyObject?) {
                
                case let .success(value): result.from = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["html"] as AnyObject?) {
                
                case let .success(value): result.html = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["recipients"] as AnyObject?) {
                
                case let .success(value): result.recipients = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["subject"] as AnyObject?) {
                
                case let .success(value): result.subject = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RawEmailResource", actual: "\(source)"))
            }
        }
        // Decoder for RawSMSResource
        Decoders.addDecoder(clazz: RawSMSResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RawSMSResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RawSMSResource() : instance as! RawSMSResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["from"] as AnyObject?) {
                
                case let .success(value): result.from = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["recipients"] as AnyObject?) {
                
                case let .success(value): result.recipients = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["text"] as AnyObject?) {
                
                case let .success(value): result.text = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RawSMSResource", actual: "\(source)"))
            }
        }
        // Decoder for ReactivateSubscriptionRequest
        Decoders.addDecoder(clazz: ReactivateSubscriptionRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReactivateSubscriptionRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ReactivateSubscriptionRequest() : instance as! ReactivateSubscriptionRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["inventory_id"] as AnyObject?) {
                
                case let .success(value): result.inventoryId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["reactivation_fee"] as AnyObject?) {
                
                case let .success(value): result.reactivationFee = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ReactivateSubscriptionRequest", actual: "\(source)"))
            }
        }
        // Decoder for RefundRequest
        Decoders.addDecoder(clazz: RefundRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RefundRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RefundRequest() : instance as! RefundRequest
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["amount"] as AnyObject?) {
                
                case let .success(value): result.amount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bundle_sku"] as AnyObject?) {
                
                case let .success(value): result.bundleSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["notes"] as AnyObject?) {
                
                case let .success(value): result.notes = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RefundRequest", actual: "\(source)"))
            }
        }
        // Decoder for RefundResource
        Decoders.addDecoder(clazz: RefundResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RefundResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RefundResource() : instance as! RefundResource
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["amount"] as AnyObject?) {
                
                case let .success(value): result.amount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["refund_transaction_id"] as AnyObject?) {
                
                case let .success(value): result.refundTransactionId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["transaction_id"] as AnyObject?) {
                
                case let .success(value): result.transactionId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RefundResource", actual: "\(source)"))
            }
        }
        // Decoder for Result
        Decoders.addDecoder(clazz: Result.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Result> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Result() : instance as! Result
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["code"] as AnyObject?) {
                
                case let .success(value): result.code = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["request_id"] as AnyObject?) {
                
                case let .success(value): result.requestId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [ErrorResource].self, source: sourceDictionary["result"] as AnyObject?) {
                
                case let .success(value): result.result = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Result", actual: "\(source)"))
            }
        }
        // Decoder for RevenueCountryReportResource
        Decoders.addDecoder(clazz: RevenueCountryReportResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RevenueCountryReportResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RevenueCountryReportResource() : instance as! RevenueCountryReportResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                
                case let .success(value): result.country = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["revenue"] as AnyObject?) {
                
                case let .success(value): result.revenue = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["volume"] as AnyObject?) {
                
                case let .success(value): result.volume = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RevenueCountryReportResource", actual: "\(source)"))
            }
        }
        // Decoder for RevenueProductReportResource
        Decoders.addDecoder(clazz: RevenueProductReportResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RevenueProductReportResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RevenueProductReportResource() : instance as! RevenueProductReportResource
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["item_id"] as AnyObject?) {
                
                case let .success(value): result.itemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["item_name"] as AnyObject?) {
                
                case let .success(value): result.itemName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["revenue"] as AnyObject?) {
                
                case let .success(value): result.revenue = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["volume"] as AnyObject?) {
                
                case let .success(value): result.volume = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RevenueProductReportResource", actual: "\(source)"))
            }
        }
        // Decoder for RevenueReportResource
        Decoders.addDecoder(clazz: RevenueReportResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RevenueReportResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RevenueReportResource() : instance as! RevenueReportResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["customer_count"] as AnyObject?) {
                
                case let .success(value): result.customerCount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["sale_count"] as AnyObject?) {
                
                case let .success(value): result.saleCount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sales_average"] as AnyObject?) {
                
                case let .success(value): result.salesAverage = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["sales_total"] as AnyObject?) {
                
                case let .success(value): result.salesTotal = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RevenueReportResource", actual: "\(source)"))
            }
        }
        // Decoder for RewardCurrencyResource
        Decoders.addDecoder(clazz: RewardCurrencyResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RewardCurrencyResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RewardCurrencyResource() : instance as! RewardCurrencyResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_name"] as AnyObject?) {
                
                case let .success(value): result.currencyName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_rank"] as AnyObject?) {
                
                case let .success(value): result.maxRank = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_rank"] as AnyObject?) {
                
                case let .success(value): result.minRank = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["percent"] as AnyObject?) {
                
                case let .success(value): result.percent = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RewardCurrencyResource", actual: "\(source)"))
            }
        }
        // Decoder for RewardItemResource
        Decoders.addDecoder(clazz: RewardItemResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RewardItemResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RewardItemResource() : instance as! RewardItemResource
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["item_id"] as AnyObject?) {
                
                case let .success(value): result.itemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["item_name"] as AnyObject?) {
                
                case let .success(value): result.itemName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_rank"] as AnyObject?) {
                
                case let .success(value): result.maxRank = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_rank"] as AnyObject?) {
                
                case let .success(value): result.minRank = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["quantity"] as AnyObject?) {
                
                case let .success(value): result.quantity = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RewardItemResource", actual: "\(source)"))
            }
        }
        // Decoder for RewardSetResource
        Decoders.addDecoder(clazz: RewardSetResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RewardSetResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RewardSetResource() : instance as! RewardSetResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [RewardCurrencyResource].self, source: sourceDictionary["currency_rewards"] as AnyObject?) {
                
                case let .success(value): result.currencyRewards = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [RewardItemResource].self, source: sourceDictionary["item_rewards"] as AnyObject?) {
                
                case let .success(value): result.itemRewards = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_placing"] as AnyObject?) {
                
                case let .success(value): result.maxPlacing = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RewardSetResource", actual: "\(source)"))
            }
        }
        // Decoder for RoleResource
        Decoders.addDecoder(clazz: RoleResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RoleResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RoleResource() : instance as! RoleResource
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["client_count"] as AnyObject?) {
                
                case let .success(value): result.clientCount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["locked"] as AnyObject?) {
                
                case let .success(value): result.locked = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["role"] as AnyObject?) {
                
                case let .success(value): result.role = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PermissionResource].self, source: sourceDictionary["role_permission"] as AnyObject?) {
                
                case let .success(value): result.rolePermission = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_count"] as AnyObject?) {
                
                case let .success(value): result.userCount = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RoleResource", actual: "\(source)"))
            }
        }
        // Decoder for S3Config
        Decoders.addDecoder(clazz: S3Config.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<S3Config> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? S3Config() : instance as! S3Config
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bucket_name"] as AnyObject?) {
                
                case let .success(value): result.bucketName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["cdn_url"] as AnyObject?) {
                
                case let .success(value): result.cdnUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["region"] as AnyObject?) {
                
                case let .success(value): result.region = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["upload_prefix"] as AnyObject?) {
                
                case let .success(value): result.uploadPrefix = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "S3Config", actual: "\(source)"))
            }
        }
        // Decoder for SampleCountriesResponse
        Decoders.addDecoder(clazz: SampleCountriesResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SampleCountriesResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SampleCountriesResponse() : instance as! SampleCountriesResponse
                switch Decoders.decodeOptional(clazz: [Country].self, source: sourceDictionary["vendor_id1"] as AnyObject?) {
                
                case let .success(value): result.vendorId1 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Country].self, source: sourceDictionary["vendor_id2"] as AnyObject?) {
                
                case let .success(value): result.vendorId2 = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SampleCountriesResponse", actual: "\(source)"))
            }
        }
        // Decoder for SavedAddressResource
        Decoders.addDecoder(clazz: SavedAddressResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SavedAddressResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SavedAddressResource() : instance as! SavedAddressResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address1"] as AnyObject?) {
                
                case let .success(value): result.address1 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                
                case let .success(value): result.address2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?) {
                
                case let .success(value): result.city = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country_code"] as AnyObject?) {
                
                case let .success(value): result.countryCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["default"] as AnyObject?) {
                
                case let .success(value): result._default = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["first_name"] as AnyObject?) {
                
                case let .success(value): result.firstName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_name"] as AnyObject?) {
                
                case let .success(value): result.lastName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone1"] as AnyObject?) {
                
                case let .success(value): result.phone1 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone2"] as AnyObject?) {
                
                case let .success(value): result.phone2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postal_code"] as AnyObject?) {
                
                case let .success(value): result.postalCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state_code"] as AnyObject?) {
                
                case let .success(value): result.stateCode = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SavedAddressResource", actual: "\(source)"))
            }
        }
        // Decoder for Schedule
        Decoders.addDecoder(clazz: Schedule.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Schedule> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Schedule() : instance as! Schedule
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["duration"] as AnyObject?) {
                
                case let .success(value): result.duration = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Schedule.DurationUnit.self, source: sourceDictionary["duration_unit"] as AnyObject?) {
                
                case let .success(value): result.durationUnit = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Schedule.Repeat.self, source: sourceDictionary["repeat"] as AnyObject?) {
                
                case let .success(value): result.repeat = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Schedule", actual: "\(source)"))
            }
        }
        // Decoder for SearchReferenceMapping
        Decoders.addDecoder(clazz: SearchReferenceMapping.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SearchReferenceMapping> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SearchReferenceMapping() : instance as! SearchReferenceMapping
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ref_id_field"] as AnyObject?) {
                
                case let .success(value): result.refIdField = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ref_type"] as AnyObject?) {
                
                case let .success(value): result.refType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["source_field_to_destination_field"] as AnyObject?) {
                
                case let .success(value): result.sourceFieldToDestinationField = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SearchReferenceMapping", actual: "\(source)"))
            }
        }
        // Decoder for SelectedSettingResource
        Decoders.addDecoder(clazz: SelectedSettingResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SelectedSettingResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SelectedSettingResource() : instance as! SelectedSettingResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["key"] as AnyObject?) {
                
                case let .success(value): result.key = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["key_name"] as AnyObject?) {
                
                case let .success(value): result.keyName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value_name"] as AnyObject?) {
                
                case let .success(value): result.valueName = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SelectedSettingResource", actual: "\(source)"))
            }
        }
        // Decoder for SettingOption
        Decoders.addDecoder(clazz: SettingOption.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SettingOption> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SettingOption() : instance as! SettingOption
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SettingOption", actual: "\(source)"))
            }
        }
        // Decoder for SimpleReferenceResourceint
        Decoders.addDecoder(clazz: SimpleReferenceResourceint.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SimpleReferenceResourceint> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SimpleReferenceResourceint() : instance as! SimpleReferenceResourceint
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SimpleReferenceResourceint", actual: "\(source)"))
            }
        }
        // Decoder for SimpleReferenceResourcelong
        Decoders.addDecoder(clazz: SimpleReferenceResourcelong.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SimpleReferenceResourcelong> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SimpleReferenceResourcelong() : instance as! SimpleReferenceResourcelong
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SimpleReferenceResourcelong", actual: "\(source)"))
            }
        }
        // Decoder for SimpleReferenceResourceobject
        Decoders.addDecoder(clazz: SimpleReferenceResourceobject.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SimpleReferenceResourceobject> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SimpleReferenceResourceobject() : instance as! SimpleReferenceResourceobject
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SimpleReferenceResourceobject", actual: "\(source)"))
            }
        }
        // Decoder for SimpleReferenceResourcestring
        Decoders.addDecoder(clazz: SimpleReferenceResourcestring.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SimpleReferenceResourcestring> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SimpleReferenceResourcestring() : instance as! SimpleReferenceResourcestring
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SimpleReferenceResourcestring", actual: "\(source)"))
            }
        }
        // Decoder for SimpleUserResource
        Decoders.addDecoder(clazz: SimpleUserResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SimpleUserResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SimpleUserResource() : instance as! SimpleUserResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["avatar_url"] as AnyObject?) {
                
                case let .success(value): result.avatarUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display_name"] as AnyObject?) {
                
                case let .success(value): result.displayName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SimpleUserResource", actual: "\(source)"))
            }
        }
        // Decoder for SimpleWallet
        Decoders.addDecoder(clazz: SimpleWallet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SimpleWallet> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SimpleWallet() : instance as! SimpleWallet
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["balance"] as AnyObject?) {
                
                case let .success(value): result.balance = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                
                case let .success(value): result.code = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_name"] as AnyObject?) {
                
                case let .success(value): result.currencyName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SimpleWallet", actual: "\(source)"))
            }
        }
        // Decoder for Sku
        Decoders.addDecoder(clazz: Sku.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Sku> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Sku() : instance as! Sku
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["inventory"] as AnyObject?) {
                
                case let .success(value): result.inventory = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_inventory_threshold"] as AnyObject?) {
                
                case let .success(value): result.minInventoryThreshold = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["original_price"] as AnyObject?) {
                
                case let .success(value): result.originalPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["price"] as AnyObject?) {
                
                case let .success(value): result.price = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                
                case let .success(value): result.published = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sale_id"] as AnyObject?) {
                
                case let .success(value): result.saleId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sale_name"] as AnyObject?) {
                
                case let .success(value): result.saleName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["start_date"] as AnyObject?) {
                
                case let .success(value): result.startDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["stop_date"] as AnyObject?) {
                
                case let .success(value): result.stopDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Sku", actual: "\(source)"))
            }
        }
        // Decoder for SkuRequest
        Decoders.addDecoder(clazz: SkuRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SkuRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SkuRequest() : instance as! SkuRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SkuRequest", actual: "\(source)"))
            }
        }
        // Decoder for SqlDatabaseConfig
        Decoders.addDecoder(clazz: SqlDatabaseConfig.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SqlDatabaseConfig> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SqlDatabaseConfig() : instance as! SqlDatabaseConfig
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["connection_pool_size"] as AnyObject?) {
                
                case let .success(value): result.connectionPoolSize = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["db_name"] as AnyObject?) {
                
                case let .success(value): result.dbName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["hostname"] as AnyObject?) {
                
                case let .success(value): result.hostname = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                
                case let .success(value): result.password = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["port"] as AnyObject?) {
                
                case let .success(value): result.port = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SqlDatabaseConfig", actual: "\(source)"))
            }
        }
        // Decoder for StateResource
        Decoders.addDecoder(clazz: StateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? StateResource() : instance as! StateResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["code"] as AnyObject?) {
                
                case let .success(value): result.code = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country_code_iso3"] as AnyObject?) {
                
                case let .success(value): result.countryCodeIso3 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "StateResource", actual: "\(source)"))
            }
        }
        // Decoder for StateTaxResource
        Decoders.addDecoder(clazz: StateTaxResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StateTaxResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? StateTaxResource() : instance as! StateTaxResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country_iso3"] as AnyObject?) {
                
                case let .success(value): result.countryIso3 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["federally_exempt"] as AnyObject?) {
                
                case let .success(value): result.federallyExempt = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["rate"] as AnyObject?) {
                
                case let .success(value): result.rate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state_code"] as AnyObject?) {
                
                case let .success(value): result.stateCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["tax_shipping"] as AnyObject?) {
                
                case let .success(value): result.taxShipping = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "StateTaxResource", actual: "\(source)"))
            }
        }
        // Decoder for StoreItemTemplateResource
        Decoders.addDecoder(clazz: StoreItemTemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StoreItemTemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? StoreItemTemplateResource() : instance as! StoreItemTemplateResource
                switch Decoders.decodeOptional(clazz: [ItemBehaviorDefinitionResource].self, source: sourceDictionary["behaviors"] as AnyObject?) {
                
                case let .success(value): result.behaviors = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PropertyDefinitionResource].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): result.properties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: TemplateResource.self, source: sourceDictionary["sku_template"] as AnyObject?) {
                
                case let .success(value): result.skuTemplate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "StoreItemTemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for StringOperationResource
        Decoders.addDecoder(clazz: StringOperationResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StringOperationResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? StringOperationResource() : instance as! StringOperationResource
                switch Decoders.decodeOptional(clazz: [ExpressionResource].self, source: sourceDictionary["args"] as AnyObject?) {
                
                case let .success(value): result.args = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["op"] as AnyObject?) {
                
                case let .success(value): result.op = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "StringOperationResource", actual: "\(source)"))
            }
        }
        // Decoder for StringWrapper
        Decoders.addDecoder(clazz: StringWrapper.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StringWrapper> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? StringWrapper() : instance as! StringWrapper
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "StringWrapper", actual: "\(source)"))
            }
        }
        // Decoder for StripeCreatePaymentMethod
        Decoders.addDecoder(clazz: StripeCreatePaymentMethod.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StripeCreatePaymentMethod> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? StripeCreatePaymentMethod() : instance as! StripeCreatePaymentMethod
                switch Decoders.decodeOptional(clazz: PaymentMethodDetails.self, source: sourceDictionary["details"] as AnyObject?) {
                
                case let .success(value): result.details = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?) {
                
                case let .success(value): result.token = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "StripeCreatePaymentMethod", actual: "\(source)"))
            }
        }
        // Decoder for StripePaymentRequest
        Decoders.addDecoder(clazz: StripePaymentRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StripePaymentRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? StripePaymentRequest() : instance as! StripePaymentRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["token"] as AnyObject?) {
                
                case let .success(value): result.token = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "StripePaymentRequest", actual: "\(source)"))
            }
        }
        // Decoder for SubscriptionCreditResource
        Decoders.addDecoder(clazz: SubscriptionCreditResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SubscriptionCreditResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SubscriptionCreditResource() : instance as! SubscriptionCreditResource
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["amount"] as AnyObject?) {
                
                case let .success(value): result.amount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["inventory_id"] as AnyObject?) {
                
                case let .success(value): result.inventoryId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["reason"] as AnyObject?) {
                
                case let .success(value): result.reason = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SubscriptionCreditResource", actual: "\(source)"))
            }
        }
        // Decoder for SubscriptionPlan
        Decoders.addDecoder(clazz: SubscriptionPlan.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SubscriptionPlan> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SubscriptionPlan() : instance as! SubscriptionPlan
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SubscriptionPlan.Availability.self, source: sourceDictionary["availability"] as AnyObject?) {
                
                case let .success(value): result.availability = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["bill_grace_days"] as AnyObject?) {
                
                case let .success(value): result.billGraceDays = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["consolidated"] as AnyObject?) {
                
                case let .success(value): result.consolidated = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["first_bill"] as AnyObject?) {
                
                case let .success(value): result.firstBill = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SubscriptionPlan.FirstBillUnitOfTime.self, source: sourceDictionary["first_bill_unit_of_time"] as AnyObject?) {
                
                case let .success(value): result.firstBillUnitOfTime = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["late_payment_sku"] as AnyObject?) {
                
                case let .success(value): result.latePaymentSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["locked"] as AnyObject?) {
                
                case let .success(value): result.locked = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_auto_renew"] as AnyObject?) {
                
                case let .success(value): result.maxAutoRenew = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_bill_attempts"] as AnyObject?) {
                
                case let .success(value): result.maxBillAttempts = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["migration_plan"] as AnyObject?) {
                
                case let .success(value): result.migrationPlan = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["minimum_term"] as AnyObject?) {
                
                case let .success(value): result.minimumTerm = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["primary_sku"] as AnyObject?) {
                
                case let .success(value): result.primarySku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["reactivation_sku"] as AnyObject?) {
                
                case let .success(value): result.reactivationSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["recurring_sku"] as AnyObject?) {
                
                case let .success(value): result.recurringSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["renew_period"] as AnyObject?) {
                
                case let .success(value): result.renewPeriod = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SubscriptionPlan.RenewPeriodUnitOfTime.self, source: sourceDictionary["renew_period_unit_of_time"] as AnyObject?) {
                
                case let .success(value): result.renewPeriodUnitOfTime = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["subscription_id"] as AnyObject?) {
                
                case let .success(value): result.subscriptionId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SubscriptionPlan", actual: "\(source)"))
            }
        }
        // Decoder for SubscriptionPlanResource
        Decoders.addDecoder(clazz: SubscriptionPlanResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SubscriptionPlanResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SubscriptionPlanResource() : instance as! SubscriptionPlanResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["billing_cycle_length"] as AnyObject?) {
                
                case let .success(value): result.billingCycleLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SubscriptionPlanResource.BillingCycleUnit.self, source: sourceDictionary["billing_cycle_unit"] as AnyObject?) {
                
                case let .success(value): result.billingCycleUnit = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["consolidated"] as AnyObject?) {
                
                case let .success(value): result.consolidated = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["end_date"] as AnyObject?) {
                
                case let .success(value): result.endDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["first_billing_cycle_length"] as AnyObject?) {
                
                case let .success(value): result.firstBillingCycleLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SubscriptionPlanResource.FirstBillingCycleUnit.self, source: sourceDictionary["first_billing_cycle_unit"] as AnyObject?) {
                
                case let .success(value): result.firstBillingCycleUnit = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["grace_period"] as AnyObject?) {
                
                case let .success(value): result.gracePeriod = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["initial_fee"] as AnyObject?) {
                
                case let .success(value): result.initialFee = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["initial_sku"] as AnyObject?) {
                
                case let .success(value): result.initialSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["late_payment_fee"] as AnyObject?) {
                
                case let .success(value): result.latePaymentFee = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["late_payment_sku"] as AnyObject?) {
                
                case let .success(value): result.latePaymentSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["locked"] as AnyObject?) {
                
                case let .success(value): result.locked = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_bill_attempts"] as AnyObject?) {
                
                case let .success(value): result.maxBillAttempts = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_cycles"] as AnyObject?) {
                
                case let .success(value): result.maxCycles = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["migrate_to_plan"] as AnyObject?) {
                
                case let .success(value): result.migrateToPlan = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_cycles"] as AnyObject?) {
                
                case let .success(value): result.minCycles = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                
                case let .success(value): result.published = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["reactivation_fee"] as AnyObject?) {
                
                case let .success(value): result.reactivationFee = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["reactivation_sku"] as AnyObject?) {
                
                case let .success(value): result.reactivationSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["recurring_fee"] as AnyObject?) {
                
                case let .success(value): result.recurringFee = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["recurring_sku"] as AnyObject?) {
                
                case let .success(value): result.recurringSku = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["start_date"] as AnyObject?) {
                
                case let .success(value): result.startDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SubscriptionPlanResource", actual: "\(source)"))
            }
        }
        // Decoder for SubscriptionPriceOverrideRequest
        Decoders.addDecoder(clazz: SubscriptionPriceOverrideRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SubscriptionPriceOverrideRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SubscriptionPriceOverrideRequest() : instance as! SubscriptionPriceOverrideRequest
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["new_price"] as AnyObject?) {
                
                case let .success(value): result.newPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["reason"] as AnyObject?) {
                
                case let .success(value): result.reason = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SubscriptionPriceOverrideRequest", actual: "\(source)"))
            }
        }
        // Decoder for SubscriptionResource
        Decoders.addDecoder(clazz: SubscriptionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SubscriptionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SubscriptionResource() : instance as! SubscriptionResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SubscriptionResource.Availability.self, source: sourceDictionary["availability"] as AnyObject?) {
                
                case let .success(value): result.availability = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Behavior].self, source: sourceDictionary["behaviors"] as AnyObject?) {
                
                case let .success(value): result.behaviors = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["consolidation_day_of_month"] as AnyObject?) {
                
                case let .success(value): result.consolidationDayOfMonth = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["geo_country_list"] as AnyObject?) {
                
                case let .success(value): result.geoCountryList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SubscriptionResource.GeoPolicyType.self, source: sourceDictionary["geo_policy_type"] as AnyObject?) {
                
                case let .success(value): result.geoPolicyType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [SubscriptionPlanResource].self, source: sourceDictionary["plans"] as AnyObject?) {
                
                case let .success(value): result.plans = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["store_end"] as AnyObject?) {
                
                case let .success(value): result.storeEnd = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["store_start"] as AnyObject?) {
                
                case let .success(value): result.storeStart = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vendor_id"] as AnyObject?) {
                
                case let .success(value): result.vendorId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SubscriptionResource", actual: "\(source)"))
            }
        }
        // Decoder for SubscriptionTemplateResource
        Decoders.addDecoder(clazz: SubscriptionTemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SubscriptionTemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? SubscriptionTemplateResource() : instance as! SubscriptionTemplateResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: TemplateResource.self, source: sourceDictionary["plan_template"] as AnyObject?) {
                
                case let .success(value): result.planTemplate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PropertyDefinitionResource].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): result.properties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "SubscriptionTemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for TemplateEmailResource
        Decoders.addDecoder(clazz: TemplateEmailResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TemplateEmailResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TemplateEmailResource() : instance as! TemplateEmailResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["from"] as AnyObject?) {
                
                case let .success(value): result.from = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["recipients"] as AnyObject?) {
                
                case let .success(value): result.recipients = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template_key"] as AnyObject?) {
                
                case let .success(value): result.templateKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [KeyValuePairstringstring].self, source: sourceDictionary["template_vars"] as AnyObject?) {
                
                case let .success(value): result.templateVars = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TemplateEmailResource", actual: "\(source)"))
            }
        }
        // Decoder for TemplateResource
        Decoders.addDecoder(clazz: TemplateResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TemplateResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TemplateResource() : instance as! TemplateResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [PropertyDefinitionResource].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): result.properties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TemplateResource", actual: "\(source)"))
            }
        }
        // Decoder for TemplateSMSResource
        Decoders.addDecoder(clazz: TemplateSMSResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TemplateSMSResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TemplateSMSResource() : instance as! TemplateSMSResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["from"] as AnyObject?) {
                
                case let .success(value): result.from = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Localizer.self, source: sourceDictionary["localizer"] as AnyObject?) {
                
                case let .success(value): result.localizer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["recipients"] as AnyObject?) {
                
                case let .success(value): result.recipients = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template_key"] as AnyObject?) {
                
                case let .success(value): result.templateKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["template_vars"] as AnyObject?) {
                
                case let .success(value): result.templateVars = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TemplateSMSResource", actual: "\(source)"))
            }
        }
        // Decoder for TierResource
        Decoders.addDecoder(clazz: TierResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TierResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TierResource() : instance as! TierResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["required_progress"] as AnyObject?) {
                
                case let .success(value): result.requiredProgress = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["trigger_event_name"] as AnyObject?) {
                
                case let .success(value): result.triggerEventName = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TierResource", actual: "\(source)"))
            }
        }
        // Decoder for TokenDetailsResource
        Decoders.addDecoder(clazz: TokenDetailsResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TokenDetailsResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TokenDetailsResource() : instance as! TokenDetailsResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client_id"] as AnyObject?) {
                
                case let .success(value): result.clientId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["roles"] as AnyObject?) {
                
                case let .success(value): result.roles = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TokenDetailsResource", actual: "\(source)"))
            }
        }
        // Decoder for TransactionResource
        Decoders.addDecoder(clazz: TransactionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TransactionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TransactionResource() : instance as! TransactionResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["create_date"] as AnyObject?) {
                
                case let .success(value): result.createDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["details"] as AnyObject?) {
                
                case let .success(value): result.details = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["is_refunded"] as AnyObject?) {
                
                case let .success(value): result.isRefunded = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["response"] as AnyObject?) {
                
                case let .success(value): result.response = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: TransactionResource.Source.self, source: sourceDictionary["source"] as AnyObject?) {
                
                case let .success(value): result.source = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["successful"] as AnyObject?) {
                
                case let .success(value): result.successful = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["transaction_id"] as AnyObject?) {
                
                case let .success(value): result.transactionId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TransactionResource", actual: "\(source)"))
            }
        }
        // Decoder for TypeHintLookupResource
        Decoders.addDecoder(clazz: TypeHintLookupResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TypeHintLookupResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TypeHintLookupResource() : instance as! TypeHintLookupResource
                switch Decoders.decodeOptional(clazz: ExpressionResource.self, source: sourceDictionary["lookup_key"] as AnyObject?) {
                
                case let .success(value): result.lookupKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value_type"] as AnyObject?) {
                
                case let .success(value): result.valueType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TypeHintLookupResource", actual: "\(source)"))
            }
        }
        // Decoder for UsageInfo
        Decoders.addDecoder(clazz: UsageInfo.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UsageInfo> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UsageInfo() : instance as! UsageInfo
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["count"] as AnyObject?) {
                
                case let .success(value): result.count = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["date"] as AnyObject?) {
                
                case let .success(value): result.date = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["method"] as AnyObject?) {
                
                case let .success(value): result.method = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): result.url = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UsageInfo", actual: "\(source)"))
            }
        }
        // Decoder for UserAchievementGroupResource
        Decoders.addDecoder(clazz: UserAchievementGroupResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserAchievementGroupResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserAchievementGroupResource() : instance as! UserAchievementGroupResource
                switch Decoders.decodeOptional(clazz: [UserAchievementResource].self, source: sourceDictionary["achievements"] as AnyObject?) {
                
                case let .success(value): result.achievements = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["group_name"] as AnyObject?) {
                
                case let .success(value): result.groupName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["progress"] as AnyObject?) {
                
                case let .success(value): result.progress = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserAchievementGroupResource", actual: "\(source)"))
            }
        }
        // Decoder for UserAchievementResource
        Decoders.addDecoder(clazz: UserAchievementResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserAchievementResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserAchievementResource() : instance as! UserAchievementResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["achieved"] as AnyObject?) {
                
                case let .success(value): result.achieved = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["achievement_name"] as AnyObject?) {
                
                case let .success(value): result.achievementName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["earned_date"] as AnyObject?) {
                
                case let .success(value): result.earnedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserAchievementResource", actual: "\(source)"))
            }
        }
        // Decoder for UserActionLog
        Decoders.addDecoder(clazz: UserActionLog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserActionLog> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserActionLog() : instance as! UserActionLog
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["action_description"] as AnyObject?) {
                
                case let .success(value): result.actionDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["action_name"] as AnyObject?) {
                
                case let .success(value): result.actionName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["details"] as AnyObject?) {
                
                case let .success(value): result.details = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["request_id"] as AnyObject?) {
                
                case let .success(value): result.requestId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserActionLog", actual: "\(source)"))
            }
        }
        // Decoder for UserActivityResults
        Decoders.addDecoder(clazz: UserActivityResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserActivityResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserActivityResults() : instance as! UserActivityResults
                switch Decoders.decodeOptional(clazz: [RewardCurrencyResource].self, source: sourceDictionary["currency_rewards"] as AnyObject?) {
                
                case let .success(value): result.currencyRewards = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [RewardItemResource].self, source: sourceDictionary["item_rewards"] as AnyObject?) {
                
                case let .success(value): result.itemRewards = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["rank"] as AnyObject?) {
                
                case let .success(value): result.rank = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["score"] as AnyObject?) {
                
                case let .success(value): result.score = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["ties"] as AnyObject?) {
                
                case let .success(value): result.ties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserActivityResults", actual: "\(source)"))
            }
        }
        // Decoder for UserActivityResultsResource
        Decoders.addDecoder(clazz: UserActivityResultsResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserActivityResultsResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserActivityResultsResource() : instance as! UserActivityResultsResource
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["score"] as AnyObject?) {
                
                case let .success(value): result.score = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserActivityResultsResource", actual: "\(source)"))
            }
        }
        // Decoder for UserBaseResource
        Decoders.addDecoder(clazz: UserBaseResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserBaseResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserBaseResource() : instance as! UserBaseResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["avatar_url"] as AnyObject?) {
                
                case let .success(value): result.avatarUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display_name"] as AnyObject?) {
                
                case let .success(value): result.displayName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): result.email = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullname"] as AnyObject?) {
                
                case let .success(value): result.fullname = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["last_activity"] as AnyObject?) {
                
                case let .success(value): result.lastActivity = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["last_updated"] as AnyObject?) {
                
                case let .success(value): result.lastUpdated = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["member_since"] as AnyObject?) {
                
                case let .success(value): result.memberSince = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserBaseResource", actual: "\(source)"))
            }
        }
        // Decoder for UserInventoryAddRequest
        Decoders.addDecoder(clazz: UserInventoryAddRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserInventoryAddRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserInventoryAddRequest() : instance as! UserInventoryAddRequest
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["note"] as AnyObject?) {
                
                case let .success(value): result.note = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["overrides"] as AnyObject?) {
                
                case let .success(value): result.overrides = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["skip_invoice"] as AnyObject?) {
                
                case let .success(value): result.skipInvoice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sku"] as AnyObject?) {
                
                case let .success(value): result.sku = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserInventoryAddRequest", actual: "\(source)"))
            }
        }
        // Decoder for UserInventoryResource
        Decoders.addDecoder(clazz: UserInventoryResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserInventoryResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserInventoryResource() : instance as! UserInventoryResource
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["behavior_data"] as AnyObject?) {
                
                case let .success(value): result.behaviorData = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["expires"] as AnyObject?) {
                
                case let .success(value): result.expires = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["item_id"] as AnyObject?) {
                
                case let .success(value): result.itemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["item_name"] as AnyObject?) {
                
                case let .success(value): result.itemName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["item_type_hint"] as AnyObject?) {
                
                case let .success(value): result.itemTypeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: UserInventoryResource.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                
                case let .success(value): result.status = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserInventoryResource", actual: "\(source)"))
            }
        }
        // Decoder for UserItemLogResource
        Decoders.addDecoder(clazz: UserItemLogResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserItemLogResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserItemLogResource() : instance as! UserItemLogResource
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["info"] as AnyObject?) {
                
                case let .success(value): result.info = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleReferenceResourceint.self, source: sourceDictionary["item"] as AnyObject?) {
                
                case let .success(value): result.item = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["log_date"] as AnyObject?) {
                
                case let .success(value): result.logDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_inventory"] as AnyObject?) {
                
                case let .success(value): result.userInventory = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserItemLogResource", actual: "\(source)"))
            }
        }
        // Decoder for UserLevelingResource
        Decoders.addDecoder(clazz: UserLevelingResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserLevelingResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserLevelingResource() : instance as! UserLevelingResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_tier_name"] as AnyObject?) {
                
                case let .success(value): result.lastTierName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["last_tier_progress"] as AnyObject?) {
                
                case let .success(value): result.lastTierProgress = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["level_name"] as AnyObject?) {
                
                case let .success(value): result.levelName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["next_tier_name"] as AnyObject?) {
                
                case let .success(value): result.nextTierName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["next_tier_progress"] as AnyObject?) {
                
                case let .success(value): result.nextTierProgress = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["progress"] as AnyObject?) {
                
                case let .success(value): result.progress = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tier_names"] as AnyObject?) {
                
                case let .success(value): result.tierNames = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["user_id"] as AnyObject?) {
                
                case let .success(value): result.userId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserLevelingResource", actual: "\(source)"))
            }
        }
        // Decoder for UserRelationshipReferenceResource
        Decoders.addDecoder(clazz: UserRelationshipReferenceResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserRelationshipReferenceResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserRelationshipReferenceResource() : instance as! UserRelationshipReferenceResource
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["avatar_url"] as AnyObject?) {
                
                case let .success(value): result.avatarUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context"] as AnyObject?) {
                
                case let .success(value): result.context = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display_name"] as AnyObject?) {
                
                case let .success(value): result.displayName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["relationship_id"] as AnyObject?) {
                
                case let .success(value): result.relationshipId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserRelationshipReferenceResource", actual: "\(source)"))
            }
        }
        // Decoder for UserRelationshipResource
        Decoders.addDecoder(clazz: UserRelationshipResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserRelationshipResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserRelationshipResource() : instance as! UserRelationshipResource
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["child"] as AnyObject?) {
                
                case let .success(value): result.child = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["context"] as AnyObject?) {
                
                case let .success(value): result.context = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["parent"] as AnyObject?) {
                
                case let .success(value): result.parent = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserRelationshipResource", actual: "\(source)"))
            }
        }
        // Decoder for UserResource
        Decoders.addDecoder(clazz: UserResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UserResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UserResource() : instance as! UserResource
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address"] as AnyObject?) {
                
                case let .success(value): result.address = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["address2"] as AnyObject?) {
                
                case let .success(value): result.address2 = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["avatar_url"] as AnyObject?) {
                
                case let .success(value): result.avatarUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [UserRelationshipReferenceResource].self, source: sourceDictionary["children"] as AnyObject?) {
                
                case let .success(value): result.children = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?) {
                
                case let .success(value): result.city = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country_code"] as AnyObject?) {
                
                case let .success(value): result.countryCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["date_of_birth"] as AnyObject?) {
                
                case let .success(value): result.dateOfBirth = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["display_name"] as AnyObject?) {
                
                case let .success(value): result.displayName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                
                case let .success(value): result.email = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["first_name"] as AnyObject?) {
                
                case let .success(value): result.firstName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["fullname"] as AnyObject?) {
                
                case let .success(value): result.fullname = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["gender"] as AnyObject?) {
                
                case let .success(value): result.gender = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["language_code"] as AnyObject?) {
                
                case let .success(value): result.languageCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["last_activity"] as AnyObject?) {
                
                case let .success(value): result.lastActivity = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["last_name"] as AnyObject?) {
                
                case let .success(value): result.lastName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["last_updated"] as AnyObject?) {
                
                case let .success(value): result.lastUpdated = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["member_since"] as AnyObject?) {
                
                case let .success(value): result.memberSince = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mobile_number"] as AnyObject?) {
                
                case let .success(value): result.mobileNumber = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [UserRelationshipReferenceResource].self, source: sourceDictionary["parents"] as AnyObject?) {
                
                case let .success(value): result.parents = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                
                case let .success(value): result.password = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postal_code"] as AnyObject?) {
                
                case let .success(value): result.postalCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["state"] as AnyObject?) {
                
                case let .success(value): result.state = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["timezone_code"] as AnyObject?) {
                
                case let .success(value): result.timezoneCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                
                case let .success(value): result.username = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UserResource", actual: "\(source)"))
            }
        }
        // Decoder for UsernameLookupResource
        Decoders.addDecoder(clazz: UsernameLookupResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<UsernameLookupResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? UsernameLookupResource() : instance as! UsernameLookupResource
                switch Decoders.decodeOptional(clazz: ExpressionResource.self, source: sourceDictionary["lookup_key"] as AnyObject?) {
                
                case let .success(value): result.lookupKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value_type"] as AnyObject?) {
                
                case let .success(value): result.valueType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "UsernameLookupResource", actual: "\(source)"))
            }
        }
        // Decoder for VariableTypeResource
        Decoders.addDecoder(clazz: VariableTypeResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VariableTypeResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? VariableTypeResource() : instance as! VariableTypeResource
                switch Decoders.decodeOptional(clazz: VariableTypeResource.Base.self, source: sourceDictionary["base"] as AnyObject?) {
                
                case let .success(value): result.base = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["enumerable"] as AnyObject?) {
                
                case let .success(value): result.enumerable = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "VariableTypeResource", actual: "\(source)"))
            }
        }
        // Decoder for VendorEmailLookupResource
        Decoders.addDecoder(clazz: VendorEmailLookupResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VendorEmailLookupResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? VendorEmailLookupResource() : instance as! VendorEmailLookupResource
                switch Decoders.decodeOptional(clazz: ExpressionResource.self, source: sourceDictionary["lookup_key"] as AnyObject?) {
                
                case let .success(value): result.lookupKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value_type"] as AnyObject?) {
                
                case let .success(value): result.valueType = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "VendorEmailLookupResource", actual: "\(source)"))
            }
        }
        // Decoder for VendorResource
        Decoders.addDecoder(clazz: VendorResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VendorResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? VendorResource() : instance as! VendorResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): result.active = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["create_date"] as AnyObject?) {
                
                case let .success(value): result.createDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["image_url"] as AnyObject?) {
                
                case let .success(value): result.imageUrl = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["manual_approval"] as AnyObject?) {
                
                case let .success(value): result.manualApproval = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["primary_contact_email"] as AnyObject?) {
                
                case let .success(value): result.primaryContactEmail = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["primary_contact_name"] as AnyObject?) {
                
                case let .success(value): result.primaryContactName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["primary_contact_phone"] as AnyObject?) {
                
                case let .success(value): result.primaryContactPhone = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["sales_email"] as AnyObject?) {
                
                case let .success(value): result.salesEmail = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["support_email"] as AnyObject?) {
                
                case let .success(value): result.supportEmail = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["update_date"] as AnyObject?) {
                
                case let .success(value): result.updateDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): result.url = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "VendorResource", actual: "\(source)"))
            }
        }
        // Decoder for Version
        Decoders.addDecoder(clazz: Version.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Version> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Version() : instance as! Version
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["version"] as AnyObject?) {
                
                case let .success(value): result.version = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Version", actual: "\(source)"))
            }
        }
        // Decoder for VideoRelationshipResource
        Decoders.addDecoder(clazz: VideoRelationshipResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VideoRelationshipResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? VideoRelationshipResource() : instance as! VideoRelationshipResource
                switch Decoders.decodeOptional(clazz: SimpleReferenceResourcelong.self, source: sourceDictionary["from"] as AnyObject?) {
                
                case let .success(value): result.from = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["relationship_details"] as AnyObject?) {
                
                case let .success(value): result.relationshipDetails = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleReferenceResourcelong.self, source: sourceDictionary["to"] as AnyObject?) {
                
                case let .success(value): result.to = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "VideoRelationshipResource", actual: "\(source)"))
            }
        }
        // Decoder for VideoResource
        Decoders.addDecoder(clazz: VideoResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VideoResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? VideoResource() : instance as! VideoResource
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["active"] as AnyObject?) {
                
                case let .success(value): result.active = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleReferenceResourcelong.self, source: sourceDictionary["author"] as AnyObject?) {
                
                case let .success(value): result.author = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["authored"] as AnyObject?) {
                
                case let .success(value): result.authored = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["banned"] as AnyObject?) {
                
                case let .success(value): result.banned = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleReferenceResourcestring.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [CommentResource].self, source: sourceDictionary["comments"] as AnyObject?) {
                
                case let .success(value): result.comments = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [ContributionResource].self, source: sourceDictionary["contributors"] as AnyObject?) {
                
                case let .success(value): result.contributors = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["embed"] as AnyObject?) {
                
                case let .success(value): result.embed = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["extension"] as AnyObject?) {
                
                case let .success(value): result._extension = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["height"] as AnyObject?) {
                
                case let .success(value): result.height = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["length"] as AnyObject?) {
                
                case let .success(value): result.length = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["location"] as AnyObject?) {
                
                case let .success(value): result.location = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["mime_type"] as AnyObject?) {
                
                case let .success(value): result.mimeType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["priority"] as AnyObject?) {
                
                case let .success(value): result.priority = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: VideoResource.Privacy.self, source: sourceDictionary["privacy"] as AnyObject?) {
                
                case let .success(value): result.privacy = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["published"] as AnyObject?) {
                
                case let .success(value): result.published = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["size"] as AnyObject?) {
                
                case let .success(value): result.size = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["thumbnail"] as AnyObject?) {
                
                case let .success(value): result.thumbnail = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["uploader"] as AnyObject?) {
                
                case let .success(value): result.uploader = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["views"] as AnyObject?) {
                
                case let .success(value): result.views = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["width"] as AnyObject?) {
                
                case let .success(value): result.width = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "VideoResource", actual: "\(source)"))
            }
        }
        // Decoder for WalletAlterRequest
        Decoders.addDecoder(clazz: WalletAlterRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WalletAlterRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? WalletAlterRequest() : instance as! WalletAlterRequest
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["delta"] as AnyObject?) {
                
                case let .success(value): result.delta = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["reason"] as AnyObject?) {
                
                case let .success(value): result.reason = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "WalletAlterRequest", actual: "\(source)"))
            }
        }
        // Decoder for WalletTotalResponse
        Decoders.addDecoder(clazz: WalletTotalResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WalletTotalResponse> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? WalletTotalResponse() : instance as! WalletTotalResponse
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["total"] as AnyObject?) {
                
                case let .success(value): result.total = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "WalletTotalResponse", actual: "\(source)"))
            }
        }
        // Decoder for WalletTransactionResource
        Decoders.addDecoder(clazz: WalletTransactionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<WalletTransactionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? WalletTransactionResource() : instance as! WalletTransactionResource
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["balance"] as AnyObject?) {
                
                case let .success(value): result.balance = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["create_date"] as AnyObject?) {
                
                case let .success(value): result.createDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["details"] as AnyObject?) {
                
                case let .success(value): result.details = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["is_refunded"] as AnyObject?) {
                
                case let .success(value): result.isRefunded = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["response"] as AnyObject?) {
                
                case let .success(value): result.response = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: WalletTransactionResource.Source.self, source: sourceDictionary["source"] as AnyObject?) {
                
                case let .success(value): result.source = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["successful"] as AnyObject?) {
                
                case let .success(value): result.successful = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["transaction_id"] as AnyObject?) {
                
                case let .success(value): result.transactionId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: SimpleUserResource.self, source: sourceDictionary["user"] as AnyObject?) {
                
                case let .success(value): result.user = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["wallet_id"] as AnyObject?) {
                
                case let .success(value): result.walletId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "WalletTransactionResource", actual: "\(source)"))
            }
        }
        // Decoder for XsollaPaymentRequest
        Decoders.addDecoder(clazz: XsollaPaymentRequest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<XsollaPaymentRequest> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? XsollaPaymentRequest() : instance as! XsollaPaymentRequest
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["invoice_id"] as AnyObject?) {
                
                case let .success(value): result.invoiceId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["return_url"] as AnyObject?) {
                
                case let .success(value): result.returnUrl = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "XsollaPaymentRequest", actual: "\(source)"))
            }
        }
        // Decoder for AudioPropertyDefinitionResource
        Decoders.addDecoder(clazz: AudioPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AudioPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? AudioPropertyDefinitionResource() : instance as! AudioPropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_type"] as AnyObject?) {
                
                case let .success(value): result.fileType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_length"] as AnyObject?) {
                
                case let .success(value): result.maxLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_length"] as AnyObject?) {
                
                case let .success(value): result.minLength = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "AudioPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for BooleanProperty
        Decoders.addDecoder(clazz: BooleanProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BooleanProperty> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BooleanProperty() : instance as! BooleanProperty
                if decoders["\(Property.self)"] != nil {
                  _ = Decoders.decode(clazz: Property.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BooleanProperty", actual: "\(source)"))
            }
        }
        // Decoder for BooleanPropertyDefinitionResource
        Decoders.addDecoder(clazz: BooleanPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BooleanPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BooleanPropertyDefinitionResource() : instance as! BooleanPropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BooleanPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for CacheClearEvent
        Decoders.addDecoder(clazz: CacheClearEvent.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CacheClearEvent> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CacheClearEvent() : instance as! CacheClearEvent
                if decoders["\(BroadcastableEvent.self)"] != nil {
                  _ = Decoders.decode(clazz: BroadcastableEvent.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client"] as AnyObject?) {
                
                case let .success(value): result.client = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer"] as AnyObject?) {
                
                case let .success(value): result.customer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["do_not_broadcast"] as AnyObject?) {
                
                case let .success(value): result.doNotBroadcast = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["section"] as AnyObject?) {
                
                case let .success(value): result.section = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["source"] as AnyObject?) {
                
                case let .success(value): result.source = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["specifics"] as AnyObject?) {
                
                case let .success(value): result.specifics = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["synchronous"] as AnyObject?) {
                
                case let .success(value): result.synchronous = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                
                case let .success(value): result.timestamp = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["customer_setup"] as AnyObject?) {
                
                case let .success(value): result.customerSetup = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["customer_teardown"] as AnyObject?) {
                
                case let .success(value): result.customerTeardown = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CacheClearEvent", actual: "\(source)"))
            }
        }
        // Decoder for Consumable
        Decoders.addDecoder(clazz: Consumable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Consumable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Consumable() : instance as! Consumable
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_use"] as AnyObject?) {
                
                case let .success(value): result.maxUse = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Consumable", actual: "\(source)"))
            }
        }
        // Decoder for DateProperty
        Decoders.addDecoder(clazz: DateProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DateProperty> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DateProperty() : instance as! DateProperty
                if decoders["\(Property.self)"] != nil {
                  _ = Decoders.decode(clazz: Property.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DateProperty", actual: "\(source)"))
            }
        }
        // Decoder for DatePropertyDefinitionResource
        Decoders.addDecoder(clazz: DatePropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DatePropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DatePropertyDefinitionResource() : instance as! DatePropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["max"] as AnyObject?) {
                
                case let .success(value): result.max = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["min"] as AnyObject?) {
                
                case let .success(value): result.min = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DatePropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for DoubleProperty
        Decoders.addDecoder(clazz: DoubleProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DoubleProperty> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DoubleProperty() : instance as! DoubleProperty
                if decoders["\(Property.self)"] != nil {
                  _ = Decoders.decode(clazz: Property.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DoubleProperty", actual: "\(source)"))
            }
        }
        // Decoder for DoublePropertyDefinitionResource
        Decoders.addDecoder(clazz: DoublePropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<DoublePropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? DoublePropertyDefinitionResource() : instance as! DoublePropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["max"] as AnyObject?) {
                
                case let .success(value): result.max = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["min"] as AnyObject?) {
                
                case let .success(value): result.min = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "DoublePropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for EntitlementItem
        Decoders.addDecoder(clazz: EntitlementItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EntitlementItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? EntitlementItem() : instance as! EntitlementItem
                if decoders["\(Item.self)"] != nil {
                  _ = Decoders.decode(clazz: Item.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Behavior].self, source: sourceDictionary["behaviors"] as AnyObject?) {
                
                case let .success(value): result.behaviors = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "EntitlementItem", actual: "\(source)"))
            }
        }
        // Decoder for Expirable
        Decoders.addDecoder(clazz: Expirable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Expirable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Expirable() : instance as! Expirable
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["time_length"] as AnyObject?) {
                
                case let .success(value): result.timeLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unit_of_time"] as AnyObject?) {
                
                case let .success(value): result.unitOfTime = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Expirable", actual: "\(source)"))
            }
        }
        // Decoder for FileGroupProperty
        Decoders.addDecoder(clazz: FileGroupProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FileGroupProperty> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FileGroupProperty() : instance as! FileGroupProperty
                if decoders["\(Property.self)"] != nil {
                  _ = Decoders.decode(clazz: Property.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [FileProperty].self, source: sourceDictionary["files"] as AnyObject?) {
                
                case let .success(value): result.files = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FileGroupProperty", actual: "\(source)"))
            }
        }
        // Decoder for FileGroupPropertyDefinitionResource
        Decoders.addDecoder(clazz: FileGroupPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FileGroupPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FileGroupPropertyDefinitionResource() : instance as! FileGroupPropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_type"] as AnyObject?) {
                
                case let .success(value): result.fileType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_count"] as AnyObject?) {
                
                case let .success(value): result.maxCount = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["max_file_size"] as AnyObject?) {
                
                case let .success(value): result.maxFileSize = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_count"] as AnyObject?) {
                
                case let .success(value): result.minCount = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FileGroupPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for FileProperty
        Decoders.addDecoder(clazz: FileProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FileProperty> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FileProperty() : instance as! FileProperty
                if decoders["\(Property.self)"] != nil {
                  _ = Decoders.decode(clazz: Property.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["crc"] as AnyObject?) {
                
                case let .success(value): result.crc = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_type"] as AnyObject?) {
                
                case let .success(value): result.fileType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["url"] as AnyObject?) {
                
                case let .success(value): result.url = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FileProperty", actual: "\(source)"))
            }
        }
        // Decoder for FilePropertyDefinitionResource
        Decoders.addDecoder(clazz: FilePropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FilePropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FilePropertyDefinitionResource() : instance as! FilePropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_type"] as AnyObject?) {
                
                case let .success(value): result.fileType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["max_file_size"] as AnyObject?) {
                
                case let .success(value): result.maxFileSize = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FilePropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for FormattedTextProperty
        Decoders.addDecoder(clazz: FormattedTextProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormattedTextProperty> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FormattedTextProperty() : instance as! FormattedTextProperty
                if decoders["\(Property.self)"] != nil {
                  _ = Decoders.decode(clazz: Property.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FormattedTextProperty", actual: "\(source)"))
            }
        }
        // Decoder for FormattedTextPropertyDefinitionResource
        Decoders.addDecoder(clazz: FormattedTextPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormattedTextPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? FormattedTextPropertyDefinitionResource() : instance as! FormattedTextPropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_length"] as AnyObject?) {
                
                case let .success(value): result.maxLength = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "FormattedTextPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for Fulfillable
        Decoders.addDecoder(clazz: Fulfillable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Fulfillable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Fulfillable() : instance as! Fulfillable
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_name"] as AnyObject?) {
                
                case let .success(value): result.typeName = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Fulfillable", actual: "\(source)"))
            }
        }
        // Decoder for GuestPlayable
        Decoders.addDecoder(clazz: GuestPlayable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<GuestPlayable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? GuestPlayable() : instance as! GuestPlayable
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["allowed"] as AnyObject?) {
                
                case let .success(value): result.allowed = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["leaderboard"] as AnyObject?) {
                
                case let .success(value): result.leaderboard = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "GuestPlayable", actual: "\(source)"))
            }
        }
        // Decoder for ImagePropertyDefinitionResource
        Decoders.addDecoder(clazz: ImagePropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ImagePropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ImagePropertyDefinitionResource() : instance as! ImagePropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_type"] as AnyObject?) {
                
                case let .success(value): result.fileType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_height"] as AnyObject?) {
                
                case let .success(value): result.maxHeight = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_width"] as AnyObject?) {
                
                case let .success(value): result.maxWidth = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_height"] as AnyObject?) {
                
                case let .success(value): result.minHeight = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_width"] as AnyObject?) {
                
                case let .success(value): result.minWidth = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ImagePropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for IntegerProperty
        Decoders.addDecoder(clazz: IntegerProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IntegerProperty> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? IntegerProperty() : instance as! IntegerProperty
                if decoders["\(Property.self)"] != nil {
                  _ = Decoders.decode(clazz: Property.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "IntegerProperty", actual: "\(source)"))
            }
        }
        // Decoder for IntegerPropertyDefinitionResource
        Decoders.addDecoder(clazz: IntegerPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<IntegerPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? IntegerPropertyDefinitionResource() : instance as! IntegerPropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max"] as AnyObject?) {
                
                case let .success(value): result.max = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min"] as AnyObject?) {
                
                case let .success(value): result.min = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "IntegerPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for LimitedGettable
        Decoders.addDecoder(clazz: LimitedGettable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LimitedGettable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LimitedGettable() : instance as! LimitedGettable
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: LimitedGettableGroup.self, source: sourceDictionary["group"] as AnyObject?) {
                
                case let .success(value): result.group = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LimitedGettable", actual: "\(source)"))
            }
        }
        // Decoder for LogLevelEvent
        Decoders.addDecoder(clazz: LogLevelEvent.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LogLevelEvent> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LogLevelEvent() : instance as! LogLevelEvent
                if decoders["\(BroadcastableEvent.self)"] != nil {
                  _ = Decoders.decode(clazz: BroadcastableEvent.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client"] as AnyObject?) {
                
                case let .success(value): result.client = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer"] as AnyObject?) {
                
                case let .success(value): result.customer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["do_not_broadcast"] as AnyObject?) {
                
                case let .success(value): result.doNotBroadcast = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["section"] as AnyObject?) {
                
                case let .success(value): result.section = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["source"] as AnyObject?) {
                
                case let .success(value): result.source = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["specifics"] as AnyObject?) {
                
                case let .success(value): result.specifics = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["synchronous"] as AnyObject?) {
                
                case let .success(value): result.synchronous = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                
                case let .success(value): result.timestamp = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["level"] as AnyObject?) {
                
                case let .success(value): result.level = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LogLevelEvent", actual: "\(source)"))
            }
        }
        // Decoder for LongProperty
        Decoders.addDecoder(clazz: LongProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LongProperty> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LongProperty() : instance as! LongProperty
                if decoders["\(Property.self)"] != nil {
                  _ = Decoders.decode(clazz: Property.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LongProperty", actual: "\(source)"))
            }
        }
        // Decoder for LongPropertyDefinitionResource
        Decoders.addDecoder(clazz: LongPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<LongPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? LongPropertyDefinitionResource() : instance as! LongPropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["max"] as AnyObject?) {
                
                case let .success(value): result.max = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["min"] as AnyObject?) {
                
                case let .success(value): result.min = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "LongPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for NewCustomerEvent
        Decoders.addDecoder(clazz: NewCustomerEvent.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<NewCustomerEvent> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? NewCustomerEvent() : instance as! NewCustomerEvent
                if decoders["\(BroadcastableEvent.self)"] != nil {
                  _ = Decoders.decode(clazz: BroadcastableEvent.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client"] as AnyObject?) {
                
                case let .success(value): result.client = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer"] as AnyObject?) {
                
                case let .success(value): result.customer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["do_not_broadcast"] as AnyObject?) {
                
                case let .success(value): result.doNotBroadcast = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["section"] as AnyObject?) {
                
                case let .success(value): result.section = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["source"] as AnyObject?) {
                
                case let .success(value): result.source = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["specifics"] as AnyObject?) {
                
                case let .success(value): result.specifics = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["synchronous"] as AnyObject?) {
                
                case let .success(value): result.synchronous = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                
                case let .success(value): result.timestamp = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CustomerConfig.self, source: sourceDictionary["customer_config"] as AnyObject?) {
                
                case let .success(value): result.customerConfig = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "NewCustomerEvent", actual: "\(source)"))
            }
        }
        // Decoder for PreReqEntitlement
        Decoders.addDecoder(clazz: PreReqEntitlement.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PreReqEntitlement> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PreReqEntitlement() : instance as! PreReqEntitlement
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["item_ids"] as AnyObject?) {
                
                case let .success(value): result.itemIds = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PreReqEntitlement", actual: "\(source)"))
            }
        }
        // Decoder for PriceOverridable
        Decoders.addDecoder(clazz: PriceOverridable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<PriceOverridable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? PriceOverridable() : instance as! PriceOverridable
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_price"] as AnyObject?) {
                
                case let .success(value): result.maxPrice = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_price"] as AnyObject?) {
                
                case let .success(value): result.minPrice = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "PriceOverridable", actual: "\(source)"))
            }
        }
        // Decoder for RemoveCustomerEvent
        Decoders.addDecoder(clazz: RemoveCustomerEvent.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RemoveCustomerEvent> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? RemoveCustomerEvent() : instance as! RemoveCustomerEvent
                if decoders["\(BroadcastableEvent.self)"] != nil {
                  _ = Decoders.decode(clazz: BroadcastableEvent.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client"] as AnyObject?) {
                
                case let .success(value): result.client = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["customer"] as AnyObject?) {
                
                case let .success(value): result.customer = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["do_not_broadcast"] as AnyObject?) {
                
                case let .success(value): result.doNotBroadcast = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["section"] as AnyObject?) {
                
                case let .success(value): result.section = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Any.self, source: sourceDictionary["source"] as AnyObject?) {
                
                case let .success(value): result.source = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["specifics"] as AnyObject?) {
                
                case let .success(value): result.specifics = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["synchronous"] as AnyObject?) {
                
                case let .success(value): result.synchronous = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["timestamp"] as AnyObject?) {
                
                case let .success(value): result.timestamp = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CustomerConfig.self, source: sourceDictionary["customer_config"] as AnyObject?) {
                
                case let .success(value): result.customerConfig = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "RemoveCustomerEvent", actual: "\(source)"))
            }
        }
        // Decoder for Spendable
        Decoders.addDecoder(clazz: Spendable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Spendable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Spendable() : instance as! Spendable
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency_code"] as AnyObject?) {
                
                case let .success(value): result.currencyCode = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Spendable", actual: "\(source)"))
            }
        }
        // Decoder for StoreItem
        Decoders.addDecoder(clazz: StoreItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<StoreItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? StoreItem() : instance as! StoreItem
                if decoders["\(Item.self)"] != nil {
                  _ = Decoders.decode(clazz: Item.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: [String:Property].self, source: sourceDictionary["additional_properties"] as AnyObject?) {
                
                case let .success(value): result.additionalProperties = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Behavior].self, source: sourceDictionary["behaviors"] as AnyObject?) {
                
                case let .success(value): result.behaviors = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["category"] as AnyObject?) {
                
                case let .success(value): result.category = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["created_date"] as AnyObject?) {
                
                case let .success(value): result.createdDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): result.id = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["long_description"] as AnyObject?) {
                
                case let .success(value): result.longDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["short_description"] as AnyObject?) {
                
                case let .success(value): result.shortDescription = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["sort"] as AnyObject?) {
                
                case let .success(value): result.sort = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["tags"] as AnyObject?) {
                
                case let .success(value): result.tags = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["template"] as AnyObject?) {
                
                case let .success(value): result.template = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unique_key"] as AnyObject?) {
                
                case let .success(value): result.uniqueKey = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["updated_date"] as AnyObject?) {
                
                case let .success(value): result.updatedDate = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["displayable"] as AnyObject?) {
                
                case let .success(value): result.displayable = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["geo_country_list"] as AnyObject?) {
                
                case let .success(value): result.geoCountryList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: StoreItem.GeoPolicyType.self, source: sourceDictionary["geo_policy_type"] as AnyObject?) {
                
                case let .success(value): result.geoPolicyType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["shipping_tier"] as AnyObject?) {
                
                case let .success(value): result.shippingTier = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [Sku].self, source: sourceDictionary["skus"] as AnyObject?) {
                
                case let .success(value): result.skus = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["store_end"] as AnyObject?) {
                
                case let .success(value): result.storeEnd = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["store_start"] as AnyObject?) {
                
                case let .success(value): result.storeStart = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["vendor_id"] as AnyObject?) {
                
                case let .success(value): result.vendorId = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "StoreItem", actual: "\(source)"))
            }
        }
        // Decoder for TextProperty
        Decoders.addDecoder(clazz: TextProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TextProperty> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TextProperty() : instance as! TextProperty
                if decoders["\(Property.self)"] != nil {
                  _ = Decoders.decode(clazz: Property.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["value"] as AnyObject?) {
                
                case let .success(value): result.value = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TextProperty", actual: "\(source)"))
            }
        }
        // Decoder for TextPropertyDefinitionResource
        Decoders.addDecoder(clazz: TextPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TextPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TextPropertyDefinitionResource() : instance as! TextPropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_length"] as AnyObject?) {
                
                case let .success(value): result.maxLength = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TextPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for TimePeriodGettable
        Decoders.addDecoder(clazz: TimePeriodGettable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TimePeriodGettable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TimePeriodGettable() : instance as! TimePeriodGettable
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["get_limit"] as AnyObject?) {
                
                case let .success(value): result.getLimit = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["group_name"] as AnyObject?) {
                
                case let .success(value): result.groupName = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["time_length"] as AnyObject?) {
                
                case let .success(value): result.timeLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unit_of_time"] as AnyObject?) {
                
                case let .success(value): result.unitOfTime = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TimePeriodGettable", actual: "\(source)"))
            }
        }
        // Decoder for TimePeriodUsable
        Decoders.addDecoder(clazz: TimePeriodUsable.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<TimePeriodUsable> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? TimePeriodUsable() : instance as! TimePeriodUsable
                if decoders["\(Behavior.self)"] != nil {
                  _ = Decoders.decode(clazz: Behavior.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): result.description = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type_hint"] as AnyObject?) {
                
                case let .success(value): result.typeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_use"] as AnyObject?) {
                
                case let .success(value): result.maxUse = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["time_length"] as AnyObject?) {
                
                case let .success(value): result.timeLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["unit_of_time"] as AnyObject?) {
                
                case let .success(value): result.unitOfTime = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "TimePeriodUsable", actual: "\(source)"))
            }
        }
        // Decoder for VideoPropertyDefinitionResource
        Decoders.addDecoder(clazz: VideoPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VideoPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? VideoPropertyDefinitionResource() : instance as! VideoPropertyDefinitionResource
                if decoders["\(PropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: PropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: PropertyFieldListResource.self, source: sourceDictionary["field_list"] as AnyObject?) {
                
                case let .success(value): result.fieldList = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): result.name = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["required"] as AnyObject?) {
                
                case let .success(value): result._required = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): result.type = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["file_type"] as AnyObject?) {
                
                case let .success(value): result.fileType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_height"] as AnyObject?) {
                
                case let .success(value): result.maxHeight = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_length"] as AnyObject?) {
                
                case let .success(value): result.maxLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_width"] as AnyObject?) {
                
                case let .success(value): result.maxWidth = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_height"] as AnyObject?) {
                
                case let .success(value): result.minHeight = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_length"] as AnyObject?) {
                
                case let .success(value): result.minLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_width"] as AnyObject?) {
                
                case let .success(value): result.minWidth = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "VideoPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for AudioGroupProperty
        Decoders.addDecoder(clazz: AudioGroupProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AudioGroupProperty> in
            if let source = source as?  {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias AudioGroupProperty", actual: "\(source)"))
            }
        }
        // Decoder for AudioGroupPropertyDefinitionResource
        Decoders.addDecoder(clazz: AudioGroupPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AudioGroupPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? AudioGroupPropertyDefinitionResource() : instance as! AudioGroupPropertyDefinitionResource
                if decoders["\(FileGroupPropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: FileGroupPropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_length"] as AnyObject?) {
                
                case let .success(value): result.maxLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_length"] as AnyObject?) {
                
                case let .success(value): result.minLength = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "AudioGroupPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for AudioProperty
        Decoders.addDecoder(clazz: AudioProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AudioProperty> in
            if let source = source as?  {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias AudioProperty", actual: "\(source)"))
            }
        }
        // Decoder for BundleItem
        Decoders.addDecoder(clazz: BundleItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<BundleItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? BundleItem() : instance as! BundleItem
                if decoders["\(StoreItem.self)"] != nil {
                  _ = Decoders.decode(clazz: StoreItem.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: [BundledSku].self, source: sourceDictionary["bundled_skus"] as AnyObject?) {
                
                case let .success(value): result.bundledSkus = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "BundleItem", actual: "\(source)"))
            }
        }
        // Decoder for CouponItem
        Decoders.addDecoder(clazz: CouponItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<CouponItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? CouponItem() : instance as! CouponItem
                if decoders["\(StoreItem.self)"] != nil {
                  _ = Decoders.decode(clazz: StoreItem.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: CouponItem.CouponTypeHint.self, source: sourceDictionary["coupon_type_hint"] as AnyObject?) {
                
                case let .success(value): result.couponTypeHint = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["discount_max"] as AnyObject?) {
                
                case let .success(value): result.discountMax = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["discount_min_cart_value"] as AnyObject?) {
                
                case let .success(value): result.discountMinCartValue = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: CouponItem.DiscountType.self, source: sourceDictionary["discount_type"] as AnyObject?) {
                
                case let .success(value): result.discountType = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["discount_value"] as AnyObject?) {
                
                case let .success(value): result.discountValue = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["exclusive"] as AnyObject?) {
                
                case let .success(value): result.exclusive = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["item_id"] as AnyObject?) {
                
                case let .success(value): result.itemId = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_quantity"] as AnyObject?) {
                
                case let .success(value): result.maxQuantity = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["self_exclusive"] as AnyObject?) {
                
                case let .success(value): result.selfExclusive = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["valid_for_tags"] as AnyObject?) {
                
                case let .success(value): result.validForTags = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "CouponItem", actual: "\(source)"))
            }
        }
        // Decoder for ImageGroupProperty
        Decoders.addDecoder(clazz: ImageGroupProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ImageGroupProperty> in
            if let source = source as?  {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias ImageGroupProperty", actual: "\(source)"))
            }
        }
        // Decoder for ImageGroupPropertyDefinitionResource
        Decoders.addDecoder(clazz: ImageGroupPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ImageGroupPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ImageGroupPropertyDefinitionResource() : instance as! ImageGroupPropertyDefinitionResource
                if decoders["\(FileGroupPropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: FileGroupPropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_height"] as AnyObject?) {
                
                case let .success(value): result.maxHeight = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_width"] as AnyObject?) {
                
                case let .success(value): result.maxWidth = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_height"] as AnyObject?) {
                
                case let .success(value): result.minHeight = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_width"] as AnyObject?) {
                
                case let .success(value): result.minWidth = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ImageGroupPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for ImageProperty
        Decoders.addDecoder(clazz: ImageProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ImageProperty> in
            if let source = source as?  {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias ImageProperty", actual: "\(source)"))
            }
        }
        // Decoder for ShippingItem
        Decoders.addDecoder(clazz: ShippingItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ShippingItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? ShippingItem() : instance as! ShippingItem
                if decoders["\(StoreItem.self)"] != nil {
                  _ = Decoders.decode(clazz: StoreItem.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["countries"] as AnyObject?) {
                
                case let .success(value): result.countries = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_tier_total"] as AnyObject?) {
                
                case let .success(value): result.maxTierTotal = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["taxable"] as AnyObject?) {
                
                case let .success(value): result.taxable = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "ShippingItem", actual: "\(source)"))
            }
        }
        // Decoder for Subscription
        Decoders.addDecoder(clazz: Subscription.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Subscription> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? Subscription() : instance as! Subscription
                if decoders["\(StoreItem.self)"] != nil {
                  _ = Decoders.decode(clazz: StoreItem.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: Subscription.Availability.self, source: sourceDictionary["availability"] as AnyObject?) {
                
                case let .success(value): result.availability = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["consolidation_day_of_month"] as AnyObject?) {
                
                case let .success(value): result.consolidationDayOfMonth = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: [SubscriptionPlan].self, source: sourceDictionary["subscription_plans"] as AnyObject?) {
                
                case let .success(value): result.subscriptionPlans = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "Subscription", actual: "\(source)"))
            }
        }
        // Decoder for VideoGroupProperty
        Decoders.addDecoder(clazz: VideoGroupProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VideoGroupProperty> in
            if let source = source as?  {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias VideoGroupProperty", actual: "\(source)"))
            }
        }
        // Decoder for VideoGroupPropertyDefinitionResource
        Decoders.addDecoder(clazz: VideoGroupPropertyDefinitionResource.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VideoGroupPropertyDefinitionResource> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let result = instance == nil ? VideoGroupPropertyDefinitionResource() : instance as! VideoGroupPropertyDefinitionResource
                if decoders["\(FileGroupPropertyDefinitionResource.self)"] != nil {
                  _ = Decoders.decode(clazz: FileGroupPropertyDefinitionResource.self, source: source, instance: result)
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_height"] as AnyObject?) {
                
                case let .success(value): result.maxHeight = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_length"] as AnyObject?) {
                
                case let .success(value): result.maxLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_width"] as AnyObject?) {
                
                case let .success(value): result.maxWidth = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_height"] as AnyObject?) {
                
                case let .success(value): result.minHeight = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_length"] as AnyObject?) {
                
                case let .success(value): result.minLength = value
                case let .failure(error): return .failure(error)
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min_width"] as AnyObject?) {
                
                case let .success(value): result.minWidth = value
                case let .failure(error): return .failure(error)
                
                }
                return .success(result)
            } else {
                return .failure(.typeMismatch(expected: "VideoGroupPropertyDefinitionResource", actual: "\(source)"))
            }
        }
        // Decoder for VideoProperty
        Decoders.addDecoder(clazz: VideoProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<VideoProperty> in
            if let source = source as?  {
                return .success(source)
            } else {
                return .failure(.typeMismatch(expected: "Typealias VideoProperty", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
